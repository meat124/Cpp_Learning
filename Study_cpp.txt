9-2 강 가변 길이 템플릿(variadic template)

-가변 길이 템플릿
-파라미터 팩
-Fold 형식
에 대해 배운다.

-가변 길이 템플릿
템플릿을 이용하면 임의의 개수의 인자를 받는 함수를 구현 가능

템플릿 파라미터 팩과 함수 파라미터 팩은 모두 . . . 을 통해 나타내지만
전자는 타입 앞에 ... 이 붙고, 후자는 타입 뒤에 ... 이 붙는다는 차이점이 있다.

파라미터 팩은 추론된 인자를 제외하고 나머지 인자들을 나타내게 된다.

main 함수에서 예시 코드를 보면
print(1, 3.1, "abc");
에서 컴파일러는 두 개의 print 함수 정의를 보고 어떤 것을 선택할지 결정한다.
첫 번째 print 는 인자를 1개만 받으므로 제외하고
두 번째 print 는 인자를 파라미터 팩으로 받으므로 이를 선택한다.

두 번째 print 는 선언이 다음과 같다.
void print(T arg, Types... args)
>> 따라서 첫 번째 전달 인자인 1은 T arg 로 들어가고 나머지 3.1 과 "abc" 는 Types... args 에 오버로딩 되어서 들어가게 된다.
따라서 위의 함수는 템플릿을 통해 다음과 같이 변화한다.
void print(int arg, double arg2, const char* arg3)
{
	std::cout << arg << ", ";
	print(arg2, arg3);
}
따라서 재귀 형태를 보이게 되며, 다시 인자 2개를 받는 print 함수를 호출한다. 그러면 다시 이 템플릿 함수를 호출하여 계속하여 print 를 진행하게 된다.
이 때 C++ 컴파일러가 함수 호출을 볼 때 인자의 개수가 같다면 파라미터 팩이 없는 함수의 우선순위를 높게 보기 때문에 주의해야 한다.
이때 템플릿 함수를 작성하고 함수의 오버로딩을 사용할 때, 컴파일러는 자신이 보고있는 함수에서 앞에 존재하는 함수들만 볼 수 있으므로 만약 함수의 순서가 잘못되면 컴파일 오류가 발생할 수 있다.

- 임의의 개수의 문자열을 합치는 함수
문자열을 합치려면 기존에
concat = s1 + s2 + s3; 를 사용했다.
이는 concat = s1.operator+(s2).operator+(s3); 와 같은 코드이다.
문제는 s2를 더할 때 메모리 할당이 발생하고, s3 를 더할 때 다시 메모리 할당이 발생할 수 있다는 점이다.
결국 합쳐진 최종 문자열의 크기는 미리 알 수 있으니 한 번에 필요한 만큼 메모리를 할당해 버리는 것이 낫다.
***메모리 할당/해제는 매우 느린 작업 중 하나이다.

문자열에 뒤에 다른 문자열을 덧붙이는 작업을 하는 함수를 strcat 이다.
이때 이 함수는 임의의 개수의인자를 받아야 한다.
따라서 가변 길이 템플릿을 사용한다.

- sizeof...
sizeof 연산자는 인자의 크기를 리턴하지만, 파라미터 팩에 sizeof... 을 사용할 경우 전체 인자의 개수를 리턴하게 된다.

- Fold Expression

가변 길이 템플릿은 매우 편리하지만 한 가지 단점이 있다.
재귀 함수 형태로 구성해야 하므로, 반드시 재귀 함수 종료를 위한 함수를 따로 "그 함수 위에" 만들어야 한다는 것이다.
즉 재귀 호출 종료를 위한 베이스 케이스를 반드시 만들어 주어야 한다.
이때 Fold 형식을 사용한다면 이를 훨씬 간단하게 표현할 수 있다.
fold 형식이란, ... 을 의미하며
return (... + nums); 라는 코드는
파라미터 팩으로 받은 모든 인자를 합하며
이를 단항 좌측 Fold (unary left fold) 라고 부른다. C++ 17 에서 지원하는 Fold 방식의 종류로 총 4가지가 존재한다.


결론 
: 가변 길이 템플릿(variadic template) 을 사용하면 인자가 여러개 들어오는 경우에도 간단하게 동적으로 표현이 가능해진다.
이 때 파라미터 팩 이라는 것을 활용하는데 템플릿 파라미터 팩은 타입 앞에 ... 을 붙이고, 함수 파라미터 팩은 타입 뒤에 ... 을 붙인다. 이 파라미터 팩을 활용해서 함수를 구현하면 재귀 호출로 원하는 결과를 얻을 수 있다.
이때 재귀 호출을 종료하기 위한 베이스 케이스 함수가 꼭 존재해야 한다. 이 베이스 케이스 함수는 인자를 1개만 받으며, 꼭 원래 함수의 위에 위치해야만 컴파일러 오류가 나지 않고 재귀함수 종료가 가능하다.
그리고 이러한 함수의 파라미터 팩으로 전달 된 인자의 개수를 보려면  sizeof... 를 이용해서 볼 수 있다. 또한 fold expression 을 이용하면 베이스 케이스 없이 그냥 간단하게 표현이 가능해진다.
단 여기서 Fold expression 은 C++ 17 이상의 버전에서만 가능하다.