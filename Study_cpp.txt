9-1강 C++ 템플릿

벡터 : 가변 길이 배열

데이터 타입이 바뀔 때 마다 다른 벡터를 만들어주어야 한다.
일반적으로 벡터는 string 타입의 문자열을 인자로 받지만, 우리가 만약에 int 또는 char 과 같은 자료형을 인자로 받고싶은 경우
코드에서 string 부분은 바꿔주어야 한다.
하지만 이는 큰 낭비이다.
만약 T 라는 타입의 객체들을 보관하는 Vector 를 만들고 싶은 경우,
이 경우 C++ 에 존재하는 템플릿의 기능이 필요하다.
즉 우리가 만약 int 를 담는 Vector 가 필요하다면 T 를 int 로 바꾸면 되고, string 을 담는 Vector 가 필요하다면, T 를 string 으로 바꾸면 된다. 이렇게 컴파일러가 알아서 T 부분에 우리가 원하는 타입으로 채워서 코드를 생성하면 편할 것이다.
즉 마치 어떠한 틀에 타입을 접어넣으면 원하는 코드가 나올 수 있게 만드는 것이다.

-C++ 템플릿(template)

>어떠한 물건을 찍어내는 틀

C++ 에서도 위와 같은 의미로 사용된다.
즉 프로그래머가 원하는 타입을 넣어주면 딱 알아서 코드를 찍어내 주는 것이다.

template <typename T> 
템플릿 선언 방식이다.
아래에 정의되는 클래스에 대해 템플릿을 정의하고, 템플릿 인자로 T 를 받게 되며, T 는 반드시 어떠한 타입의 이름임을 명시하고 있다.
만약 밑에 오는 것이 클래스가 아니라 함수이면 함수에 대한 템플릿이 된다.
template <class T> 라는 선언도 존재한다. 이는 위와 동일한 것이다.

이를 메인 함수에서 선언하려면
Vector<int> int_vec; 
클래스이름 <원하는 타입> 인스턴스이름
순으로 코드를 작성하면 된다.
여태까지는 인자로 특정한 값 혹은 객체를 전달했지만, 타입 그 자체를 전달한 적은 없었다. 하지만 이제 템플릿을 사용하면서 이게 가능해진다.

클래스 템플릿에 인자를 전달해서 실제 코드를 생성하는 것을 클래스 템플릿 인스턴스화 라고 한다.
템플릿이 인스턴스화 되지 않고 있다면 컴파일 시에 아무런 코드로 변환되지 않는다.
이때 간혹 일부 타입에 대해서는 다른 방식으로 처리해야 할 필요가 있다.
만약 bool 타입의 데이터를 보관하는 벡터에 대해 생각해보자
Vector<bool> int_vec;
이러한 경우에 특수하게 처리를 해주어야 한다.

-템플릿 특수화(template specialization)
template <typename A, typename B, typename C> 일 때, 만약 원하는 인자에 따라서 다르게 처리하고 싶다면
class test<int , B, double> 처럼 원하는 인자만 골라서 처리해주면 된다.
위의 경우는 선언을 다음과 같이 한다.
template<typename B>
class test<int, B, double>
>> typename A 와 C 를 각각 int 와 double 로 결정하고 템플릿 인자로는 B 만 받고 싶은 경우 위와 같이 선언한다.

*** bool 타입이 1비트가 아니라 8비트, 즉 1바이트로 표현되는 이유 : single bit 에 포인터를 생성하려면 addressable 해야 한다. 하지만 1비트라면 포인터 생성이 불가하다. 따라서 bool 타입의 변수는 1바이트로 표현되어야 한다. 
이는 모든 타입의 변수에 동일하게 적용된다. 따라서 C++ 의 모든 데이터 타입은 절대로 1바이트 보다 작을 수 없다!
boolean 의 저장 방식
if true
0000 0001
if false
0000 0000
용량이 1 바이트인 자료형은 원래 2^8 가지의 수를 표현이 가능하다.
하지만 boolean 은 1비트만 표현가능, 즉 2가지의 수만 표현이 가능하다(참, 거짓)
따라서 참, 거짓만을 표현할 때는 int형(4바이트) 보다는 메모리 절약이 가능하지만 그 이외에는 매우 효율이 떨어진다.

^ 연산자 : 서로 다르다면 1을, 같다면 0을 반환
<< , >> 연산자 : 비트를 이동하는 시프트 연산, <<는 왼쪽으로, >> 는 오른쪽으로 이동한다. 이를 좀 더 자세히 보면, << 연사는은 2의 거듭제곱을 곱하는 것이고, >> 는 2의 거듭제곱으로 나누는 것이다.

unsigned int 에서 i / 32 는 10진수 형태로 구하는 것이고, i % 32 는 2진수 형태로 구하는 것이다.

비트 연산에서 기존의 비트에 1을 OR 연산하게 되면 그 비트는 무조건 1이 된다.
아래의 형태를 보자
OR 연산
001001010101
000010000000
>001011010101
즉 기존의 비트는 그대로 유지하면서 0인 부분에 1을 대입한 것을 볼 수 있다.
data[length / 32] |= (1 << (length % 32));
위의 코드에서 좌변을 보면
data 의 배열에서 length / 32, 즉 배열의 현재 길이를 32로 나눈 몫의 요소에 접근한다. length 는 현재 비트 단위로 표현하고 있으므로 만약 비트가 32 를 넘지 못하면 0, 32~63까지는 1, 64~95까지는 2.. 이런 식으로 접근하게 된다.
따라서 1 << (length % 32) 연산을 통해서 정확히 length % 32 번 째 비트만 1로 바꾼다.
1은 비트로 표현하면 0000 0001 이므로 여기서 왼쪽 시프트 연산으로 원하는 칸 수에 도달할 수 있다.
따라서 이렇게 원하는 위치의 요소를 OR 연산으로 int 의 자리를 true 로 만들 수 있다.

연산자 오버로딩에서는 &(AND) 연산을 활용한다.
AND 연산을 통해 해당 값을 가져올 수 있다.
어떤 비트에 0 을 AND 하게 되면, 그 비트는 무조건 0 이 되고, 1을 AND 연산하게 되면, 해당 비트가 1이여야지만 1이 된다.
AND 연산은 둘 다 1인 경우에만 1을 만들기 때문
따라서 원하는 위치의 인덱스를 찾으면 그 값이 1일 때 1을 반환하고, 0이면 0을 반환하게 된다.

*** 특정 비트 단위의 배열에 접근해서 연산하는 방법
만약 인자로 int 형 변수 a 를 받으면
(1 << (a % 32)) 연산으로 원하는 위치에 접근이 가능하다.
1 은 비트 표현으로 0000 0001 로 표현된다.

^ 비트 연산자 : 두 비트가 같으면 0, 다르면 1이 되는 연산
0xFFFFFFFF 는 모든 비트가 1인 int > 32개의 비트가 모두 1
여기서 0xFFFFFFFF ^= (1 << (prev % 32)); 코드는
(1 << (prev % 32)) 가 원하는 위치에 1을 배치하고 나머지는 0 이므로
1인 위치는 같으므로 0이 되고, 나머지 0인 부분은 1과 다르므로 1이 된다.
즉 원하는 위치를 0으로 만들고 나머지는 1로 만들 수 있다.


-템플릿 함수
이전에 템플릿 클래스는 인스턴스화 할 때 (클래스 이름)<템플릿 인자 타입> 으로 선언했는데
함수는 그러지 않아도 컴파일러가 알아서 전달되는 인자의 타입을 확인해서 변환해준다.
string 의 경우도 마찬가지이다. 변수가 아니라 클래스여도 max<string>(s,t) 로 생각해서 인스턴스화 해준다.

bubble_sort 함수를 템플릿으로 구현한다.
컴파일러가 인자로 전달된 객체의 타입을 보고 알아서 인스턴스화 한 뒤에 컴파일 하게 된다.
만약 인자가 Vector<int> 타입이면, 템플릿을 두 번 사용하는 것이 된다.
Vector 를 int 로 템플릿 사용 >> bubble_sort 에서 한 번 더 사용

그런데 만약 여기서 함수 내부에 사용되는 함수가 인자로 전달된 인스턴스의 클래스 내부에 존재하지 않는다면 컴파일 오류가 발생한다. 
즉 클래스에서 멤버 함수나 변수들을 찾을 수 없다는 오류가 발생한다. 이러한 오류는 컴파일 시에 발생한다. 왜냐하면 컴파일 시에 모든 템플릿을 실제 코드로 변환하기 때문.

*** 버블 정렬에서 오름차순이 아니라 내림차순으로 , 또는 다르게 정렬하고 싶다면
1. 부등호 방향을 반대로 해준다.
2. operator> 를 오버로딩해서 원하는 방식으로 만든다.
3. cont[i] 와 cont[j] 의 비교를 > 로 하지 말고 특정 함수에 넣어서 전달한다.

2 번 방법에서 int 나 string 은 이미 내부적으로 operator< 가 정의되어 있으므로 오버로딩이 불가하다.
따라서 3번째 방법을 사용해본다.

- 함수 객체(Function Object - Functor) 의 도입

array 라이브러리 사용방법
std::array<int, 5> arr = {1,2,3,4,5};
>> 자료형이 int 이고 5개의 요소를가지는 배열 arr 선언

이 배열을 함수의 인자로 전달하면 함수 선언에서 매개변수에 요소의 개수까지 적어야 하지만
템플릿을 사용한다면 이 요소의 개수를 정하지 않고도 사용이 가능하다.
template <typename T>
void print_array(const T& arr)

- 디폴트 템플릿 인자
함수에 디폴트 인자를 지정할 수 있는 것 처럼 템플릿도 디폴트 인자를 지정할 수 있다.
template <typename T, int num = 5>
>> num 이 전달되지 않으면 5로 디폴트로 초기화 하고 실행