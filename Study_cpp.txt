C++은 엄청나게 많은 분야에서 사용된다.
게임엔진, 컴파일러, 운영체제(윈도우), 크롬, 딥러닝, 서버(구글), 금융분야 등등

>>>프로그램의 성능이 중요한 부분에서 널리 쓰인다.

C언어에 클래스를 추가한 언어를 만든 Bjarne Stroustrup은 처음에 C++을 C with Classes라고 이름을 붙였다.
C++의 첫 번째 표준은 C++98이다. 현재는 C++23까지 발표된 상태. 
C++11부터 대격변패치가 이뤄지면서 이 버전부터 Modern C++이라고 부른다.

-1강

C++은 C와 문법만 비슷하고 상당히 다른 언어이다.

iostream 헤더파일은 표준 입출력에 필요한 것들을 포함한다. 예를 들면 std::cout, std::endl와 같은 것들
C언어에서의 stdio.h와 비슷하다. 다만 뒤에 .h가 붙지 않는다.
이름공간(namespace)
cout앞에 붙어있는 std는 C++표준 라이브러리의 모든 함수, 객체 등이 정의된 이름공간이다. 이름 공간은 말 그대로 "어떤 정의된 객체에 대해 어디 소속인지" 지정해 주는 것과 동일하다.
C++에서는 코드의 크기가 늘어나면서, 또는 다른 사람들이 쓴 코드를 가져다 쓰는 경우가 많아지면서 중복된 이름을 가지는 경우가 많이 발생하여 그 함수들을 구분하기 위해 소속을 나누게 된다. 따라서 함수의 이름이 같더라도 소속이 다르면, 즉 namespace가 다르면 다른 함수로 취급하기로 했다.
이름 공간을 정의하는 방법
두 헤더파일을 정의한다 생각하면
namespace header1

즉 cout 와 endl은 모두 iostream의 헤더파일의 std라는 이름공간(namespace)에 정의되어 있는 것이다. 따라서 std라는 이름공간을 호출때 마다 적기 싫다면 
using namespace std;
라는 구문으로 앞으로 호출을 없앨 수 있다.
하지만 이러한 방법은 권장되지 않는다. 
왜냐하면 std에 이름이 겹치는 함수를 만들게 된다면 오류가 발생할 수 있기 때문이다.
C++ 표준 라이브러리는 매우 거대해서 엄청나게 많은 함수들이 존재한다. 만약 실수로 이름을 겹치게 사용한다면 이를 수정하는데 많은 시간을 할당하게 된다. 따라서 std에 계속해서 새로운 함수들이 추가되고 있기 때문에 C++버전이 바뀔 때 마다 기존에 잘 작동하던 함수들이 겹치게 되면 코드가 이름 충돌로 인해 동작하지 않게 되는 문제가 발생할 수 있다.

따라서 이러한 방식은 간편하지만 권장하지 않고 std::를 직접 앞에 붙여서 std라는 namespace의 함수이다 라고 명시하는 것이 좋다. 또한 내가 작성하는 코드는 나만의 namespace에 넣어서 혹시 모를 이름충돌로 부터 보호하는 것이 중요하다.

cout는 ostream 클래스의 객체이다. 표준 출력(C언어에서의 stdout)에 대응된다.

hi
my name is Psi

cin은 scanf의 역활을 한다. 이때 C에서는 입력받은 변수를 저장할 때 &연산자를 활용했는데 cin은 그럴 필요가 없다. 
cout 는 << 인데 cin 은 >> 이다.
std::cin >> 변수이름


-2강

C++에 새로 도입된 새로운 개념인 Reference에 대해 알아본다.

C언어에서는 어떠한 변수를 가리키고 싶을 때 반드시 포인터를 사용해야 했다. 하지만 C++에서는 다른 변수나 상수를 가리키는 방법으로 또 다른 방식을 제공한다. 이를 참조자(Reference)라고 한다.

레퍼런스와 포인터는 몇 가지 중요한 차이점이 있다.
1. 레퍼런스는 처음에 정의할 경우 반드시 누구의 별명인지 명시해야 한다.
따라서 int& another_a 같은 문장은 불가능하다. 
반면 포인터는 int* another_a 가 가능하다.

2. 레퍼런스가 한 번 별명이 되면 절대로 다른 이의 별명이 될 수 없다.
int& another_a = a; 로 인해 a의 별명이 된 경우
another_a = b; 라는 문장은 b의 별명이 되라는 문장이 아니라 a의 값에 b를 대입하라는 문장이 된다.
즉 a = b; 와 같다.
만약 &another_a = b; 을 쓰면 이는 그냥 &a = b; 가 되어서 말이 안되는 문장이 된다.

반면 포인터는 가리키는 대상을 변경이 맘대로 가능하므로 레퍼런스와 차이점을 가지게 된다.

3. 레퍼런스는 메모리 상에 존재하지 않을 수도 있다.
만약 포인터를 선언한다면 포인터는 메모리에서 4또는8바이트를 차지하게 된다.
컴파일러는 another_a를 위해 메모리 상에 공간을 할당할 필요가 없다. 왜냐하면 그냥 코드에서 another_a로 쓰인 문장은 a로 바꿔치고 생각하면 되기 때문이다. 따라서 이런 경우는 레퍼런스가 메모리 상에 존재하지 않게 된다. 하지만 무조건 존재하지 않는 것은 아니다.

함수 인자로 전달되는 경우를 생각해본다.
함수 인자로 전달할 경우에 함수 선언에 매개변수 선언은 int& p 로 해주고 전달 인자를 num으로 해주면 이는 합쳐서 int& p = num; 이 된다.
p가 정의되는 순간은 함수로 호출할 때 이므로 위의 문장이 성립한다.

즉 이 경우에는 함수를 호출할 때 전달 인자에 &를 붙이지 않아도 된다. 포인터로 인자를 전달하는 경우에는 주소값을 반환하는 연산자인 &를 붙여야 했다.
참조자(레퍼런스)를 사용하는 경우에는 포인터보다 코드를 훨씬 간결하게 나타낼 수 있어 유용하다. 즉 불필요한 &, *연산자를 없앨 수 있다.

앞에서 살펴본 cin을 보자
std::cin >> user_input;이라는  문장은 굳이 C언어에서 처럼 &user_input을 할 필요 없이 cin함수가 user_input을 자동으로 레퍼런스로 받는다.

만약 레퍼런스로 상수를 가리키게 된다면 레퍼런스의 값을 변경할 때 상수의 값, 즉 리터럴의 값을 변경하게 되면서 오류가 발생한다.
따라서 C++의 문법에서는 상수 리터럴을 일반적인 레퍼런스로 참조하게 되어있다.
다만 선언을 const선언으로 해서 변경이 불가능하게 한다면 리터럴도 레퍼런스로 참조가 가능하다.

레퍼런스의 배열은 불가능하다 라고 규정에 나와있다.
레퍼런스의 레퍼런스, 레퍼런스의 배열, 레퍼런스의 포인터는 존재할 수 없다.

문법 상 배열의 이름은 배열의 첫 번째 원소의 주소값으로 변환이 가능해야 한다. 주소값이 존재한다는 의미는 해당 원소가 메모리에 존재한다는 말과 같다. 하지만 위에서 보았듯이 레퍼런스는 특별한 경우가 아니면 메모리 상에서 굳이 공간을 차지할 이유가 없다. 따라서 이러한 모순 때문에 레퍼런스의 배열은 선언과 동시에 초기화가 되어야 하는데 이는 메모리의 공간을 차지하게 되므로 금지시킨 것이다.

하지만 그의 반대인 배열들의 레퍼런스는 가능하다.

함수의 반환형을 레퍼런스로 지정한 경우 그 함수에서 선언된 변수를 반환하게 되면 main함수로 돌아왔을 경우 레퍼런스의 값은 반환이 되었지만 레퍼런스만 남아있고 그 변수는 메모리에서 사라진 상태이므로 오류가 발생한다. 이러한 사라진 레퍼런스를 dangling reference라고 부른다. 따라서 레퍼런스를 리턴하는 함수에서 지역 변수의 레퍼런스를 리턴하지 않도록 주의한다.

외부 변수의 레퍼런스를 리턴하는 경우
매개변수로 int& a 를 받고 이를 다시 return a를 통해 리턴하는 경우
가능

레퍼런스의 참조값을 함수 리턴값으로 하는 경우
불가능>>댕글링레퍼런스


힙 메모리에 할당할 때
new - delete
new type[] - delete[] 과 매칭된다.


Animal에서 Bird와 Fish로 세분화를 하고 싶을 경우 하나하나 구조체를 다시 작성하는 것은 매우 비효율적이다. 따라서 Animal 구조체에서 공통인 부분을 승계하면 된다.
C언어에서는 이를 구조체를 하나하나 작성하고 관리했지만 C++에서는 더 이상 이렇게 하지 않아도 된다.
이는 C++이 객체지향 프로그래밍을 지원하기 때문에 가능한 이야기이다.
1. 객체 지향 프로그래밍의 도래
2. 객체란 무엇인가, 클래스란 무엇인가
3. 접근 지시자(public, private)

C언어를 이용해서 대형 프로젝트를 진행하기에는 어렵다는 것을 위에서 깨달았다.

진공관 상에서 단순한 전선 연결 배치로 명령을 내렸던 언어가 1세대 컴퓨터 언어이다.

1950년에 이후 컴퓨터 내장 메모리가 만들어지고 실질적으로 컴퓨터 프로그래밍이라고 부를만한 것을 할 수 있게 되자 2세대 컴퓨터 언어가 등장하였다. 가장 먼저 나온 것은 Assembly language이다. 언어라고 하기보다는 컴퓨터에 직접 명령을 내리는 기계어에 사람들이 보기 쉽게 문자열을 대응시킨 것에 가까웠다.
Fortran, basic 등등 어셈블리어에 비해서는 매우 복잡한 명령을 가볍게 처리하는 획기적인 발전이 이뤄졌다. 즉 저급 언어에서 고급언어로의 발전이 이뤄진 것이다.
하지만 여전히 문제는 존재했다. 데이터 타입이나 프로그램 문법 구조가 완전하지 않아서 복잡한 데이터 타입을 모두 배열로 처리한다든지, 논리 구조를 모두 goto문으로 처리해서 흐름의 분기가 꼬인다든지 하는 등의 문제가 있었다.
이렇게 코드를 짜게되면 오류가 발생하여도 그 오류의 원인이 어디인지 찾기가 힘들어지는 스파게티 코드가 된다. 
따라서 체계적인 프로그래밍 언어의 필요성이 대두된다.

그래서 등장한 3세대 프로그래밍 언어는 절차지향 언어라고 불리는 Pascal 언어와 그 다음 C언어가 등장하게 된다.
절차지향 언어로 몇십년을 버텨오다 이제 프로그램의 크기가 예전과는 상상도 할 수 없을 정도로 커지게 되자 이제는 새로운 패러다임이 필요하게 된다.
바로 객체지향 언어이다(Object oriented language, OOP)
이를 사용하는 언어는 C++, Java, Python, C# 등등 90년대 이후에 생긴 언어들은 대부분 객체지향 언어이다.
물론 C++은 객체지향언어라고 단정짓기에는 어렵다. C++은 템플릿을 이용해서 제너릭한 프로그래밍도 가능하고 모던 C++에 들어서서는 함수형 프로그래밍도 가능하다. 또한 절차지향 프로그래밍도 당연히 가능하다. 따라서 C++은 멀티 패러다임으로 보는 것이 바람직하다.

그렇다면 객체(object)란 무엇인지 알아보자.

위에서 살펴본 Animal구조체를 보면 구조체 정의를 한 뒤 play함수에 전달해줬다.
하지만 이러한 인자전달은 불필요하다.
따라서 이를 변경할 수 있다.
이젠 play함수에 animal을 인자로 주지 않아도 된다.
내가 play하는 것이기 때문에 내 정보를 이미 play함수가 다 알고있기 때문이다.
play함수는 나의 상태를 모두 알고 이에 대한 적절한 처리를 할 수 있다. 즉 animal 은 자신의 상태를 알려주는 변수, 자신이 하는 행동들을 수행한느 함수들로 이뤄졌다고 볼 수 있다.
따라서 객체는 다음과 같이 정의된다.
"변수들과 참고 자료들로 이루어진 소프트웨어 덩어리"
이때 객체가 현실세계에서의 존재하는 것들을 나타내기 위해서는 추상화(abstraction)과정이 필요하다. 컴퓨터 상에서 현실 세계를 100%나타낼 수 없기 때문에 처리할 수 있도록 변환시키는 것이다. 따라서 현실세계의 행위를 함수로 변환해야한다.
객체의 변수와 함수를 각각 인스턴스 변수(instance variable), 인스턴스 메소드(instance method)라고 부른다. 따라서 인스턴스 메소드라는 말을 들으면 객체에 정의되어 있는 함수라고 생각하면 된다.

객체를 그림으로 표현한 것에서 보면 Methods가 Variable을 보호하고 있는 것처럼 묘사된다. 이는 변수들이 외부로부터 보호받고 있기 때문이다. 따라서 외부에서 객체의 instance variable을 변경하지 못하고 오직 instance method를 통해서만 변경이 가능하다는 것이다. 항상 그런것은 아니지만 일반적으로 그렇게 이뤄진다.

이와 같이 외부에서 직접 인스턴스 변수의 값을 바꿀 수 없고 항상 인스턴스 메소드를 통해서 간접적으로 값을 조절하는 것을 캡슐화(Encapsulation)라고 부른다.
겉으로 볼 때는 animal.food += 100; 과 animal.increase_food(100); 의 차이점이 없어보인다.
간단하게 보면 장점은 다음과 같다. "객체가 내부적으로 어떻게 작동하는지 몰라도 사용할 줄 알게 된다."
즉 animal.increase_food(100);을 하면 내부적으로 food 변수값이 100 증가하는 것 뿐만이 아니라 몸무게도 바꿀 수 있고 행복도도 변화가능하고 등등 여러가지 작업이 동시에 일어날 수 있다. 하지만 이러한 함수를 사용하지 않는다면 프로그래머가 이를 하나하나 처리해줘야 한다. 이는 food를 100늘리는 과정에서 정확히 어떤 일이 일어나는지를 파악해야만 처리할 수 있는 아주 귀찮은 문제이다. 따라서 대형 프로젝트에서는 객체를 한 사람이 설계하는 것이 아니기 때문에 이러한 인스턴스 메소드를 활용하게 된다. 따라서 food를 늘리려면 그냥 increase_food를 이용하면 그와 연관된 나머지 작업들은 모두 함수가 알아서 하게 되므로 간편해지는 것이다.

키보드의 경우에도 마찬가지이다. 만약 '키보드의 a를 누른다' 라는 행위는 우리가 컴퓨터에서 어떠한 연산이 이뤄지는지 알 필요가 없다. 따라서 my_computer.keyboard_hit('a') 라는 인스턴스 메소드를 호출하는 것으로 생각하면 된다.

따라서 캡슐화로 인해 얼마나 작업이 편해지는지 알 수 있다.

-클래스
C++에서 객체를 만들어 낼 수 있는 장치가 바로 클래스(Class)이다. 쉽게 말해도 객체의 설계도라고 볼 수 있다.
C++에서 클래스를 이용해서 만들어진 객체를 instance라고 부른다. 따라서 앞에서 다룬 변수와 함수를 인스턴스 변수, 인스턴스 메소드라고 부르는 이유를 알 수 있다.

main함수에서 Animal 클래스의 인스턴스를 생성하였다.
구조체에서 구조체 변수를 생성할 때와 동일하다. 구조체의 경우 앞에 struct 를 명시해야 했지만 class는 그럴 필요 없이 바로 변수 이름만 적어도 된다.
따라서 Animal animal; 만 하면 인스턴스가 생성되는 것이다.
이 Animal 클래스에서는 food, weight라는 변수가 있고, set_animal, increase_food, view_stat이라는 함수들이 있다. 이들을 지칭할 때 각각 멤버 변수(member variable), 멤버 함수(member function)이라고 부른다.

즉 인스턴스로 생성된 객체에서는 인스턴스 변수, 인스턴스 함수, 그리고 그냥 클래스에서는 멤버 변수, 멤버 함수라고 부르는 것이다. 멤버 변수와 멤버 함수는 인스턴스가 만들어져야 실재하게 되는 것이다. 설계도 상에 있다고 해서 아파트가 실제로 존재하는것이 아닌 것처럼 말이다.

클래스에서 멤버 변수를 정의한 부분을 보면, 새로운 키워드가 나온다. private, public 이다. 이를 접근 지시자 라고 한다. 외부에서 이러한 멤버들에 접근을 할 수 있냐 없냐를 정해주는 역활이라 보면 된다. 따라서 private는 외부에서 접근이 불가하고 public은 외부에서 접근이 가능하다. 따라서private키워드 아래에 쓰여진 것은 객체 내에서 보호받고 있다. 즉 private된 것들은 자기 객체 안에서만 접근이 가능하고 외부에서는 접근이 불가하다. 따라서 private된 변수를 변경하려면 public에 있는 함수에서 접근을 해야 한다.
public은 외부에서 이용이 가능하다. 
접근 지시자 키워드 명시를 하지 않았다면 기본적으로 private으로 설정된다. 따라서 처음에 private키워드를 지워도 자동으로private으로 설정이 된다.
만약 멤버 변수들도 public으로 공개하면 구조체처럼 객체 밖에서도 접근이 가능한 형태가 된다.

객체란 무엇인가? : 객체 또는 오브젝트(object)는 클래스에서 정의한 것을 토대로 메모리에 할당된 것으로, 프로그램에서 사용되는 데이터 또는 식별자에 의해 참조되는 공간을 의미한다. 객체 내부는 변수, 자료구조, 함수, 메소드가 될 수 있다. 객체의 설계도는 클래스에 의해 만들어지고 이 객체가 선언되어서 메모리에 할당되기 전 까지는 객제는 존재하지 않는 상태이다. 설계도만 존재하는 상태인 것이다. 절차적 프로그래밍에서는 하나의 객체는 자료나 명령 중 하나만 포함할 수 있다.
하지만 객체지향 프로그래밍에서는 객체는 클래스의 인스턴스이다. 따라서 객체는 자료와 명령을 조합하여 존재한다. 객체가 메시지를 받고 자료를 처리하여 메시지를 다른 객체로 보낼 수 있다.

클래스 : 클래스는 객체의 설계도를 만드는 방식이다. 즉 객체를 만들어 낼 수 있는 장치이다. 이 클래스로 만들어진 객체를 instance(인스턴스)라고 부른다.
인스턴스 : 클래스로 만들어진 객체를 인스턴스라 부른다.
인스턴스 변수 : 인스턴스에 존재하는 변수
인스턴스 함수 : 인스턴스에 존재하는 함수이며 이를 통해 변수로 접근이 가능하면 인스턴스 메소드라 정의한다.
멤버 변수 : 클래스 내부에 존재하는 변수(실재x)
멤버 함수 : 클래스 내부에 존재하는 함수

-함수의 오버로딩(Overloading)
C에서는 하나의 이름을 가지는 함수가 딱 1개만 존재할 수 밖에 없다. 하지만 C++에서는 같은 이름을 가진 함수가 여러개 존재해도 된다. 따라서 함수의 과부하, 즉 함수의 오버로딩이 발생할 수 있게 되었다.
C++은 같은 이름을 가진 함수를 호출했을 경우 사용하는 인자를 보고 결정을 내린다.
고전적인 C의 컴파일러는 오류가 발생하지만 C++에서는 인자가 다르면 다른 함수라고 판단하기 때문에 오류가 발생하지 않는다.
함수를 오버로딩하는 과정은 다음과 같다.
1. 자신과 타입이 정확히 일치하는 함수를 찾는다.
2. 정확히 일치하는 타입이 없으면 아래의 형변환을 통해 일치하는 함수를 찾는다.
char, unsigned char, short는 int 로 형변환등등
Float는 double 로 형변환
3. 좀 더 포괄적인 형변환을 통해 일치하는 함수를 찾는다.
4. 유저 정의된 타입 변환으로 일치하는 것을 찾는다.
만약 위의 과정을 거쳐도 일치하는 함수를 찾을 수 없거나 같은 단계에서 두 개 이상 일치하는 경우에는 모호하다(ambiguous)라고 판단해서 오류가 발생한다.

만약 double이 오버로딩 걸린 경우 double은 3단계에서 char,int로 형변환이 모두 가능하므로 두 개 이상의 일치가 발생해서 오류가 발생하게 된다.

클래스 내부에서 함수의 정의만 선언하고 함수의 몸통은 외부에 존재하는 경우가 있다. 이는 클래스 내부에서 함수의 몸통이 존재하게 되면 클래스의 내부가 복잡해지는 상황을 막기위해 이러한 방식을 사용한다. 따라서 클래스 내부의 함수를 만들려면 반환형 클래스이름::함수이름 을 이용하여 선언하면 된다.
만약 일반적으로 함수를 선언하는 것 처럼 하게 되면 그 함수는 클래스의 멤버함수가 아니라 그냥 일반적인 함수가 되어버린다. 따라서 간단한 함수를 제외하면 대부분의 함수들은 클래스의 바깥에서 정의하게 된다. 클래스의 내부는 최대한 깔끔하게 유지하는것이 바람직하다.

생성자(constructor)
: 기본적으로 "객체 생성 시 자동으로 호출되는 함수" 라고 볼 수 있다.
이때 자동으로 호출되면서 객체를 초기화하는 역활을 담당한다.
이 생성자는 객체를 초기화하는 역활을 하기 때문에 리턴값이 존재하지않는다.

생성자 선언 방식은 다음과 같다.
클래스 이름 (인자)
{
	초기화 내용
}
이 생성자를 사용하면 생성 후 초기화를 숙지하지 못했더라도 이 문제를 언어 차원에서 해결할 수 있다.

명시적 방법으로도 생성자의 호출이 가능하지만 암시적 방법이 가능하므로 가능하면 이를 선호하는 편이다.

디폴트 생성자(Default Constructor)
: 만약 SetDate함수를 이용해서 객체를 초기화 시킬 때 생성자를 명시하지 않았다.
즉 처음에 생성자 정의를 하지 않고 단순히 인스턴스 선언만 했을때도 생성자가 호출되는가? 그렇다.
이러한 경우를 디폴트 생성자라고한다.
이는 인자를 하나도 가지지 않는 생성자이다. 클래스에서 사용자가 어떠한 생성자도명시적으로 정의하지 않았을 때 컴파일러가 자동으로 추가해주는 생성자이다. 
이 디폴트 생성자를 정의하는 것도 가능하다.

오버로딩이란 인자를 통해 동일한 이름의 함수 중에서 어떤 함수를 사용할지 판단하는 것을 의미한다. 정확하게 일치하는 자료형이 없다면 자료형을 형변환을 해가면서 판단을 내린다.