5-2강

이번 강좌에서는
1. 멤버 함수가 아닌 연산자 함수 오버로딩
2. 입출력 연산자 오버로딩(<<, >> 연산자)
3. 첨자 연산자 [] 오버로딩
4. 타입 변환 연산자 오버로딩
5. 증감 연산자 ++, -- 오버로딩
에 대해 다룬다.

-friend 키워드
friend 키워드는 클래스 내부에서 다른 클래스나 함수들을 friend로 정의할 수 있다. 이때 이 키워드로 정의된 클래스나 함수들은 원래 클래스의 private 으로 정의된 변수나 함수에 접근할 수 있다.

A 클래스 내부에 클래스 B와 void func 를 friend 키워드를 붙여서 선언하고 있다. 이는 친구라고 선언하는 것이다. 이러한 선언을 통해 클래스 B와 void func는 A클래스에 접근권한을 얻게된다.
하지만 A 클래스는 반대로 B 클래스에 접근이 불가능하다.

std::ostream& operator<<(std::ostream& os, const Complex& c)
위의 코드에서 인자로 받는 std::ostream& os 는 
이항 연산자에서 cout << c;
라는 코드에서 연산자인 << 양쪽에 존재하는 cout 가 std::ostream& os 로 들어가고 c 가 const Complex& c로 들어가는 것이다.

-이항 연산자
저번 강좌에서 다음과 같은 문제점이 있었다.
a = a + "-1.1 + i3.923";
는 잘 컴파일 되지만
a = "-1.1 + i3.923";
은 컴파일 되지 않았다.
왜냐하면 위는 a.operator+("i3.923"); 으로 변환되지만 아래는 그렇지 못하기 때문이다.
하지만 아래가 컴파일 되지 않는다면 연산자 오버로딩을 할 이유가 없다.
어떤 임의의 연산자 @ 가 존재한다면
*a.operator@(b);
*operator@(a,b); 
중 컴파일러가 가능한 것을 골라서 처리한다. 따라서 위의 코드는 a 클래스의 멤버 함수로 사용되고, operator@(a,b)는 클래스 외부에 정의되어 있는 일반적인 함수를 의미한다. 따라서 이를 처리하기 위한 새로운 함수를 정의해야 한다.
여기서 인자를 Complex& a 라는 인자로 받는다.
그런데 우리는 문자열에 써있는 복소수를 변수로 변환시켜서 계산하기를 원한다.
따라서 이 문자열을 Complex 클래스의 변수로 변환시키는 생성자가 존재하기 때문에 연산이 가능해진다. 즉 const char* str을 인자로 받는 생성자가 사용된다.
따라서 오버로딩이 되면서 인자가 변환된다.
즉 const Complex& a 라는 인자에 문자열 "-1.1 + i3.923" 이라는 인자가 전달되면 이는 
Complex("-1.1 + i3.923") 이라는 생성자로 변환되어 변수에 저장된다.
>> 오버로딩 적용
그런데 Complex operator+ 함수가 제대로 작동하려면 이 함수가 Complex 클래스의 private 변수인 a,b의 real, img 변수에 접근이 가능해야한다. 따라서 이 함수를 Complex 클래스에 friend 키워드를 이용해서 선언하면 된다.

자기 자신을 리턴하지 않는 이항연산자는 +,-,*,/  전부 외부 함수로 선언하는 것이 원칙이다. 반대로 자기 자신을 리턴하는 이항연산자(+=, -= 등) 은 멤버 함수로 선언하는 것이 원칙이다.

iostream 헤더파일을 보면 그 안에 istream, ostream 이 include 되어있다.
여기서 엄청난 수의 operator<< 연산이 정의되어 있는 것을 알 수 있다. 즉 오버로딩이 되고 있는 것이다. 따라서 우리가 이를 통해서 편하게 인자의 타입과 상관없이 bool, short, int, double 등등.. 많은 것을을 출력할 수 있게 되는 것이다.
그렇다면 우리가 이를 이용해서 
Complex c;
std::cout << c; 
를 출력으로 나타내고싶으면 어떻게 해야할까.
우리가 표준헤더파일을 수정할 수는 없으므로 우리가 직접 만들어본 클래스에 연산자 함수를 추가하면 된다. 
여기서 리턴 타입이 ostream& 가 되는 이유는 
std::cout << "a 의 값은 : " << a << " 이다. " << std::endl;
이라는 문장을 처리할 수 있게 하기 위해서이다.

무분별한 friend 키워드 남발은 권장되지 않는다.
"구현 디테일은 최대한 숨겨라" 라는 원칙을 지키기가 힘들어지기 때문이다.
따라서 상황을 보면서 friend 가 꼭 필요한 상황에만 사용하는 것이 바람직하다.

-첨자 연산자([])

배열에서 원소를 지정할 때 사용되는 첨자 연산자 [] 를 오버로딩 해본다.
[] 안에 들어가는 수를 첨자(subscript)라고 부른다.
예를 들어 str[10] 이라는 코드는 str 배열의 10번째 인덱스의 값에 접근하게 해준다.
코드는 다음과 같다
char& operator[](const int index) { return string_content[index]; }

-int Wrapper 클래스(타입 변환 연산자)
무언가를 포장하는 클래스 라는 의미를 가지며
C++ 에서 기본 자료형들을 객체로써 다루어야 할 때가 있다.
int, float와 같은 기본 자료형들을 클래스로 포장해서 다룰 때 필요한 것이 Wrapper 클래스이다.
int 자료형을 감싸는 int Wrapper 클래스 Int 는 다음과 같다.

class Int
{
   int data;

 public:
   Int(int data) : data(data) {}
   Int(const Int& i) : data(i.data) {}
}


-전위/후위 증감 연산자
전위 연산자는
operator++();
operator--(); 이라는 방식으로 오버로딩을 진행한다.
후위 연산자는
operator++(int x);
operator--(int x);
여기서 인자 x는 아무런 의미가 없다. 
다만 컴파일러가 전위/후위를 구별하기 위해 인자를 넣어주는 것이다.
따라서 다음과 같이 선언해도 차이는 없다
operator++(int)
operator--(int)

전위 증감 연산의 경우 값이 바뀐 자기 자신을 리턴하고, 후위 증감의 경우 값이 바뀌기 이전의 객체를 리턴한다.
int x = 1;
func(++x); 
라는 코드는 전위 증감 연산이므로 func에 2를 인자로 전달하지만
int x = 1;
func(x++);
라는 코드는 후위 증감 연산이므로 func에 1을 인자로 전달하고 증감을 해서 x = 2가 된다.
따라서 이는 다음과 같은 형태가 된다.
A& operator++()
{
   return *this
} // 전위연산

A& operator++(int)
{
   A temp(A);
   // A++ 을 수행한다.
   return temp;
} // 후위 연산

++을 하기 전에 객체를 반환해야 하므로 temp 객체를 임시로 만들어서 이전의 상태를 기록하고 ++을 수행한 뒤 temp 객체를 반환하게 된다. 따라서 후위 증감 연산은 전위 증감 연산에 비해 추가적으로 복사 생성자를 호출하기 때문에 전위 증감 연산보다 속도가 조금 느리게 된다.

-연산자 오버로딩 정리
1. 두 개의 동등한 객체 사이에서의 이항 연산자는 멤버 함수가 아닌 외부 함수로 오버로딩 하는 것이 좋다.( 예를 들어 Complex 의 operator+(const Complex&, const Complex&) 와 같은 함수)
2. 두 개의 객체 사이의 이항 연산자 이지만 한 객체만 값이 바뀐다든지 하는 등의 동등하지 않은 이항 연산자는 멤버 함수로 오버로딩 하는 것이 좋다. 
예를 들어 operator+= 는 이항 연산자 이지만 실제로는 한쪽으로만 값이 변경되므로 
operator+=(const Complex&) 가 더 나은 경우에 해당된다.
3. 단항 연산자는 멤버 함수로 오버로딩하는 것이 좋다.
예를 들어 operator++ 의 경우 멤버 함수로 오버로딩한다.
4. 일부 연산자들은 반드시 멤버 함수로만 오버로딩 해야 한다.

5-3강

-C++스타일의 캐스팅
C언어에서는 컴파일러에서 알아서 캐스팅하는 암시적 캐스팅과, 우리가 직접 캐스팅하라고 지정하는 명시적 캐스팅이 존재했다.
암시적 캐스팅의 경우 int 와 double 변수와의 덧셈을 수행할 때, int 형 변수가 자동으로 double 변수로 캐스팅 되는 것을 말했다. 그리고 명시적 캐스팅의 경우 void* 타입의 주소를 특정 구조체 포인터 타입의 주소로 바꾸는 등의 캐스팅이 존재했다.

이때 명시적 캐스팅은 앞에 () 를 붙이고 형을 명시하는 식으로 진행되었다.
하지만 이러한 캐스팅 방법은 다음과 같은 상황에서 문제가 발생한다.
1. 말도 안되는 캐스팅에 대해 컴파일러가 오류를 발생시키지 않는다. 즉 프로그래머의 실수에 취약하다.
2. 코드의 가독성이 떨어진다. 괄호안에 타입을 넣으므로
괄호가 많아지면 가독성이 떨어지게 된다.

따라서 C++ 에서는 총 4가지의 캐스팅을 지원한다.
1. static_cast : 우리가 흔히 생각하는, 언어적 차원에서 지원하는 일반적인 타입 변환
2. const_cast : 객체의 상수성(const)를 없애는 타입 변환, 쉽게 말해 const int 가 int 로 바뀐다.
3. dynamic_cast : 파생 클래스 사이에서의 다운 캐스팅
4. reinterpret_cast : 위험을 감수하고 하는 캐스팅(서로 관련이 없는 포인터들 사이의 캐스팅)

예를 들어서 static_cast 로 float 타입의 float_variable 이라는 변수를 int 타입의 변수로 변환하기 위해서는
static_cast<int>(float_variable);
이렇게 코드를 작성하면 된다.
이는 (int)(float_variable); 이라는 코드와 동일한 문장이다.
대부분의 캐스팅은 보통 static_cast로 진행이 된다.

-N 차원 배열 만들기
사용자가 원하는 배열의 차원이 존재한다면
그 배열을 일차원으로 구현한 뒤에 접근할 경우 그 정확한 위치를 찾아주는 방식으로 N차원 배열의 생성이 가능하다.
동적으로 2차원 배열을 구현할 때 다음과 같은 코드를 통해 구현하였다.
int** arr; // 이중포인터 선언
arr = new int*[x1]; // 먼저 포인터로 1차 동적할당
for(int i=0;i<x1;i++)
   arr[i] = new int[x2];

이러면 아래로 가지를 뻗는 듯한 모습으로 배열의 할당이 가능해진다.
3차원 배열은 삼중포인터를 사용해서 선언하면 된다.
즉 문어발 형식으로 배열을 구현하는 것이다.
처음에는 x1개의 int* 배열을 생성한 뒤, 각각의 int*에 대해서 x2개의 int 배열을 만드는 것이다.
이러하면 int arr[x1][x2] 를 한 것과 정확히 동일한 효과를 낸다.
하지만 이러한 방식은 메모리를 추가적으로 더 잡아먹는다.
int arr[x1][x2]는 메모리를 x1*x2 만큼 잡아먹지만
위에서 다룬 방식은 메모리를 x1*x2 + x1 + 1만큼 잡아먹는다는 단점이 존재한다.

하지만 장점도 존재한다.
이러한 방식은 메모리가 허용하는 한, 크기가 매우매우 큰 배열도 생성할 수 있다는 점이다.

구조체를 통해서 다음과 같이 선언을 한다.
struct Address
{
   int level;
   void* next;
}
이렇게 하면 처음에 top이라는 Address 객체를 도입이 되고 거기에 level = 0; 이 저장된다. 그리고 top의 next에는 레벨 1인 Address 배열의 시작 주소가 들어간다. 그렇게 되면 top이 가리키고 있는 Address 배열의 각각 원소들의 level은 1이 되고, 이들의 next 에는 이번에는 Address 배열이 아닌, int 배열의 시작주소가 들어가게 된다.(왜냐하면 2차원 배열이므로 이제 마지막이기 때문, 실질적으로 데이터는 이 곳에 보관이 된다.)
이때 포인터는 타입에 상관없이 값을 보관해야 하므로 void* 포인터로 선언하며 이는 필요할 때 적당한 포인터 타입으로 변환하면 된다.
즉, 최종적으로 N 차원 배열은 Address 에서 0레벨부터 N - 1 레벨까지 생성되며, N-1 레벨의 경우 next 에 실제로 보관할 데이터에 해당하는 배열(int) 의 시작 주소값이 들어가게 되며, 나머지 0~N-2레벨까지는 그 다음 레벨의 Address 배열의 시작 주소값이 들어가게 된다.
즉 3차원 배열의 경우
(3-1) 레벨의 Address 들의 next가 int 배열의 시작주소값을 가리키게 된다.

이러한 방식을 도입하는 이유는 각 레벨에서의 배열 크기가 모두 다를 수 있기 때문이다.
예를 들어서 arr[3][2][1] 을 했을 경우, 1 레벨의 배열 크기가 3이고 2레벨의 배열 크기가 2리고 마지막 int 배열의 크기가 1이 된다.

>>배열은 레벨 방식을 도입해서 처리한다.
이러한 아이디어를 바탕으로 N 차원의 배열을 설계한다.

먼저 배열에 들어가야 할 정보는 '몇 차원' 배열인지, 그리고 각 차원에 대한 크기 정보를 반드시 포함해야 한다.
따라서 차원은 dim 이라는 변수에, 그리고 각 차원에 대한 크기는 size 라는 포인터로 배열을 생성해서 저장한다.
이때 dim 을 const 선언을 이용해서 상수로 정한 것은 외부 사용자들에게 차원을 한 번 정하면 바꿀 수 없다는 것을 의미한다. 만약 차원을 변경하길 원한다면 이에 대한 함수를 조정하면 된다.
여기서 실질적으로 데이터를 보관하는 부분은 나무에서 끝 뿌리 부분에 존재한다.
이 시작점은 Address* 타입으로 정한다.
이를 top 이라고 한다.
이 때 Address 타입을 클래스 안에 선언할 수 있다.
우리는 외부에서 배열이 내부적으로 어떻게 작동하는지 공개하고 싶지 않고, 내부 정보에 접근하는 것을 원하지 않기 때문에 구조체를 내부에 선언한다.
여기서 C++ 에서는 구조체는 모든 멤버 함수, 변수가 디폴트로 public 인 클래스라고 생각하면 된다.
private 은 오직 클래스로 선언해야 사용가능

먼저 배열을 생성해야 한다. 하지만 여기서 우리의 배열은 N차원 배열이기 때문에 for 문을 이용해서는 생성하기가 불가능하다. 따라서 재귀 함수를 사용한다.
재귀 함수를 구성하려면 다음의 스탭을 생각해야 한다.
1. 함수에서 처리하는 것, 즉 현재 단계에서 다음 단계로 넘어가는 과정은 무엇인가?
2. 재귀 호출이 종료되는 조건은 무엇인가?
일단 재귀 호출이 종료되려면 Address 배열의 레벨이 dim - 1에도달하면 된다.
즉 배열의 레벨이 도달하면 이제 next 포인터에 int 배열의 데이터가 들어가면서 호출이 종료되게 된다.
그렇다면 현재 단계에서 다음 레벨로 넘어가기 위한 과정은 무엇인가?
> 현재 n 레벨의 Address 배열이라면 이들의 next에 다음 레벨인 n + 1 레벨의 Address 배열을 지정해 준 다음, 이 각각의 원소에 대해 처리하게 하는 것이다.

(current->next) + i 는 current->next를 시작 주소값으로 하는 Address 배열의 i번째 원소를 가리키는 포인터를 의미한다.
이러한 방식으로 재귀 호출을 하게 되면 깊이 우선 탐색을 하는 것과 같은 형태가 이뤄진다.
소멸자도 이러한 방식으로 만들어주면 된다.
다만 생성자는 위에서 아래로 메모리를 확장했지만, 소멸자는 아래에서 위로 메모리를 해제해야 한다.
따라서 재귀 함수의 시작에 인자로 current 에 top을 전달했다. 그리고 이 top을 시작으로 함수들이 재귀호출로 계속해서 호출되게 된다.
그렇게 재귀 함수가 모두 진행되면, 거대한 N차원의 메모리 구조가 생성되거나 소멸된다.
소멸자에서 동적으로 할당한 모든 것들을 정리해 주어야 한다. 재귀호출로 생성한 메모리 구조만을 소멸하는 것이 아니라 size 역시 동적으로 할당한 것이므로 꼭 해제해 주어야 한다.
또한 복사 생성자에서 마찬가지로 트리 안에 모든 원소들을 복사해주어야 한다.

이제 배열을 생성을 하였다.
하지만 여기서 원소에 접근하는 방법은 또 다른 방법으로 해야한다.
C++에서는 1개의 []를 취하는 연산자는 존재하지만 여러개의 [] 를 취하는 연산자는 없다.
arr[1][2][3][4] 원소의 접근을 생각해 본다.
먼저 arr[1] 이 처리되어서 객체를 리턴한다.
Array 가 아닌 새로운 타입의 객체를 만들어야 한다.
operator[] Array& 타입을 리턴하면 
arr[1] = 3; 은 말이 안되는 코드이다.
하지만 만약 int& 타입을 리턴해도 고차원 배열에서는
arr[1][2] = 3; 과 같은 코드는 컴파일이 불가능하다.
따라서 오버로딩 원칙 상, 동일한 인자를 받는 경우에 함수에서는 한 가지 리턴 타입만이 가능하다.
이러한 문제를 해결하기 위해 Wrapper 클래스를 사용한다.
중간 단계의 T나 T' 처럼 원소에 접근해 가는 경우, 중간 단계의 정보를 포함하는 것으로 사용하면 된다.
이러한 형태로 int 의 Wrapper 클래스를 만들어본다.
먼저 level 정보는 반드시 포함해야 한다.
만약 Int 가 맨 마지막 실제 int 정보를 저장하는곳에 도달한 경우, 그 정보를 포함하고 있는 객체인지, 아니면 중간과정인지를 판단해야 하기 때문이다.
예를 들어서 arr[1][2] 를 생각해보면 arr[1] 는 중간과정이지만 [2] 는 최종적으로 정보를 저장하는 곳이기 때문이다. 여기서 level을 구분하려면 Int 가 가지고 있는 array의 dim 을 참고하면 된다.
array 는 어떤 배열의 Int 인지 가리키는 역할을 한다.

Int 의 생성자는 아래와 같다.

인자로 들어가는 값들에 값을 미리 대입하는 것을 디폴트 인자라고 한다.
함수에 값을 전달해주지 않는다면 기본으로 이 값들이 들어가게 된다.
다만 함수의 원형을 정확히 알아야지, 일부 인자를 실수로 누락하게 된다면 디폴트 인자가 경고로 발생하지 않고, 그로 인해 함수가 이상하게 작동할 수 있으므로 주의가 필요하다.
