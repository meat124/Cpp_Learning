C++은 엄청나게 많은 분야에서 사용된다.
게임엔진, 컴파일러, 운영체제(윈도우), 크롬, 딥러닝, 서버(구글), 금융분야 등등

>>>프로그램의 성능이 중요한 부분에서 널리 쓰인다.

C언어에 클래스를 추가한 언어를 만든 Bjarne Stroustrup은 처음에 C++을 C with Classes라고 이름을 붙였다.
C++의 첫 번째 표준은 C++98이다. 현재는 C++23까지 발표된 상태. 
C++11부터 대격변패치가 이뤄지면서 이 버전부터 Modern C++이라고 부른다.

-1강

C++은 C와 문법만 비슷하고 상당히 다른 언어이다.

iostream 헤더파일은 표준 입출력에 필요한 것들을 포함한다. 예를 들면 std::cout, std::endl와 같은 것들
C언어에서의 stdio.h와 비슷하다. 다만 뒤에 .h가 붙지 않는다.
이름공간(namespace)
cout앞에 붙어있는 std는 C++표준 라이브러리의 모든 함수, 객체 등이 정의된 이름공간이다. 이름 공간은 말 그대로 "어떤 정의된 객체에 대해 어디 소속인지" 지정해 주는 것과 동일하다.
C++에서는 코드의 크기가 늘어나면서, 또는 다른 사람들이 쓴 코드를 가져다 쓰는 경우가 많아지면서 중복된 이름을 가지는 경우가 많이 발생하여 그 함수들을 구분하기 위해 소속을 나누게 된다. 따라서 함수의 이름이 같더라도 소속이 다르면, 즉 namespace가 다르면 다른 함수로 취급하기로 했다.
이름 공간을 정의하는 방법
두 헤더파일을 정의한다 생각하면
namespace header1

즉 cout 와 endl은 모두 iostream의 헤더파일의 std라는 이름공간(namespace)에 정의되어 있는 것이다. 따라서 std라는 이름공간을 호출때 마다 적기 싫다면 
using namespace std;
라는 구문으로 앞으로 호출을 없앨 수 있다.
하지만 이러한 방법은 권장되지 않는다. 
왜냐하면 std에 이름이 겹치는 함수를 만들게 된다면 오류가 발생할 수 있기 때문이다.
C++ 표준 라이브러리는 매우 거대해서 엄청나게 많은 함수들이 존재한다. 만약 실수로 이름을 겹치게 사용한다면 이를 수정하는데 많은 시간을 할당하게 된다. 따라서 std에 계속해서 새로운 함수들이 추가되고 있기 때문에 C++버전이 바뀔 때 마다 기존에 잘 작동하던 함수들이 겹치게 되면 코드가 이름 충돌로 인해 동작하지 않게 되는 문제가 발생할 수 있다.

따라서 이러한 방식은 간편하지만 권장하지 않고 std::를 직접 앞에 붙여서 std라는 namespace의 함수이다 라고 명시하는 것이 좋다. 또한 내가 작성하는 코드는 나만의 namespace에 넣어서 혹시 모를 이름충돌로 부터 보호하는 것이 중요하다.

cout는 ostream 클래스의 객체이다. 표준 출력(C언어에서의 stdout)에 대응된다.

hi
my name is Psi

cin은 scanf의 역활을 한다. 이때 C에서는 입력받은 변수를 저장할 때 &연산자를 활용했는데 cin은 그럴 필요가 없다. 
cout 는 << 인데 cin 은 >> 이다.
std::cin >> 변수이름


-2강

C++에 새로 도입된 새로운 개념인 Reference에 대해 알아본다.

C언어에서는 어떠한 변수를 가리키고 싶을 때 반드시 포인터를 사용해야 했다. 하지만 C++에서는 다른 변수나 상수를 가리키는 방법으로 또 다른 방식을 제공한다. 이를 참조자(Reference)라고 한다.

레퍼런스와 포인터는 몇 가지 중요한 차이점이 있다.
1. 레퍼런스는 처음에 정의할 경우 반드시 누구의 별명인지 명시해야 한다.
따라서 int& another_a 같은 문장은 불가능하다. 
반면 포인터는 int* another_a 가 가능하다.

2. 레퍼런스가 한 번 별명이 되면 절대로 다른 이의 별명이 될 수 없다.
int& another_a = a; 로 인해 a의 별명이 된 경우
another_a = b; 라는 문장은 b의 별명이 되라는 문장이 아니라 a의 값에 b를 대입하라는 문장이 된다.
즉 a = b; 와 같다.
만약 &another_a = b; 을 쓰면 이는 그냥 &a = b; 가 되어서 말이 안되는 문장이 된다.

반면 포인터는 가리키는 대상을 변경이 맘대로 가능하므로 레퍼런스와 차이점을 가지게 된다.

3. 레퍼런스는 메모리 상에 존재하지 않을 수도 있다.
만약 포인터를 선언한다면 포인터는 메모리에서 4또는8바이트를 차지하게 된다.
컴파일러는 another_a를 위해 메모리 상에 공간을 할당할 필요가 없다. 왜냐하면 그냥 코드에서 another_a로 쓰인 문장은 a로 바꿔치고 생각하면 되기 때문이다. 따라서 이런 경우는 레퍼런스가 메모리 상에 존재하지 않게 된다. 하지만 무조건 존재하지 않는 것은 아니다.

함수 인자로 전달되는 경우를 생각해본다.
함수 인자로 전달할 경우에 함수 선언에 매개변수 선언은 int& p 로 해주고 전달 인자를 num으로 해주면 이는 합쳐서 int& p = num; 이 된다.
p가 정의되는 순간은 함수로 호출할 때 이므로 위의 문장이 성립한다.

즉 이 경우에는 함수를 호출할 때 전달 인자에 &를 붙이지 않아도 된다. 포인터로 인자를 전달하는 경우에는 주소값을 반환하는 연산자인 &를 붙여야 했다.
참조자(레퍼런스)를 사용하는 경우에는 포인터보다 코드를 훨씬 간결하게 나타낼 수 있어 유용하다. 즉 불필요한 &, *연산자를 없앨 수 있다.

앞에서 살펴본 cin을 보자
std::cin >> user_input;이라는  문장은 굳이 C언어에서 처럼 &user_input을 할 필요 없이 cin함수가 user_input을 자동으로 레퍼런스로 받는다.

만약 레퍼런스로 상수를 가리키게 된다면 레퍼런스의 값을 변경할 때 상수의 값, 즉 리터럴의 값을 변경하게 되면서 오류가 발생한다.
따라서 C++의 문법에서는 상수 리터럴을 일반적인 레퍼런스로 참조하게 되어있다.
다만 선언을 const선언으로 해서 변경이 불가능하게 한다면 리터럴도 레퍼런스로 참조가 가능하다.

레퍼런스의 배열은 불가능하다 라고 규정에 나와있다.
레퍼런스의 레퍼런스, 레퍼런스의 배열, 레퍼런스의 포인터는 존재할 수 없다.

문법 상 배열의 이름은 배열의 첫 번째 원소의 주소값으로 변환이 가능해야 한다. 주소값이 존재한다는 의미는 해당 원소가 메모리에 존재한다는 말과 같다. 하지만 위에서 보았듯이 레퍼런스는 특별한 경우가 아니면 메모리 상에서 굳이 공간을 차지할 이유가 없다. 따라서 이러한 모순 때문에 레퍼런스의 배열은 선언과 동시에 초기화가 되어야 하는데 이는 메모리의 공간을 차지하게 되므로 금지시킨 것이다.

하지만 그의 반대인 배열들의 레퍼런스는 가능하다.

함수의 반환형을 레퍼런스로 지정한 경우 그 함수에서 선언된 변수를 반환하게 되면 main함수로 돌아왔을 경우 레퍼런스의 값은 반환이 되었지만 레퍼런스만 남아있고 그 변수는 메모리에서 사라진 상태이므로 오류가 발생한다. 이러한 사라진 레퍼런스를 dangling reference라고 부른다. 따라서 레퍼런스를 리턴하는 함수에서 지역 변수의 레퍼런스를 리턴하지 않도록 주의한다.

외부 변수의 레퍼런스를 리턴하는 경우
매개변수로 int& a 를 받고 이를 다시 return a를 통해 리턴하는 경우
가능

레퍼런스의 참조값을 함수 리턴값으로 하는 경우
불가능>>댕글링레퍼런스


힙 메모리에 할당할 때
new - delete
new type[] - delete[] 과 매칭된다.


Animal에서 Bird와 Fish로 세분화를 하고 싶을 경우 하나하나 구조체를 다시 작성하는 것은 매우 비효율적이다. 따라서 Animal 구조체에서 공통인 부분을 승계하면 된다.
C언어에서는 이를 구조체를 하나하나 작성하고 관리했지만 C++에서는 더 이상 이렇게 하지 않아도 된다.
이는 C++이 객체지향 프로그래밍을 지원하기 때문에 가능한 이야기이다.
1. 객체 지향 프로그래밍의 도래
2. 객체란 무엇인가, 클래스란 무엇인가
3. 접근 지시자(public, private)

C언어를 이용해서 대형 프로젝트를 진행하기에는 어렵다는 것을 위에서 깨달았다.

진공관 상에서 단순한 전선 연결 배치로 명령을 내렸던 언어가 1세대 컴퓨터 언어이다.

1950년에 이후 컴퓨터 내장 메모리가 만들어지고 실질적으로 컴퓨터 프로그래밍이라고 부를만한 것을 할 수 있게 되자 2세대 컴퓨터 언어가 등장하였다. 가장 먼저 나온 것은 Assembly language이다. 언어라고 하기보다는 컴퓨터에 직접 명령을 내리는 기계어에 사람들이 보기 쉽게 문자열을 대응시킨 것에 가까웠다.
Fortran, basic 등등 어셈블리어에 비해서는 매우 복잡한 명령을 가볍게 처리하는 획기적인 발전이 이뤄졌다. 즉 저급 언어에서 고급언어로의 발전이 이뤄진 것이다.
하지만 여전히 문제는 존재했다. 데이터 타입이나 프로그램 문법 구조가 완전하지 않아서 복잡한 데이터 타입을 모두 배열로 처리한다든지, 논리 구조를 모두 goto문으로 처리해서 흐름의 분기가 꼬인다든지 하는 등의 문제가 있었다.
이렇게 코드를 짜게되면 오류가 발생하여도 그 오류의 원인이 어디인지 찾기가 힘들어지는 스파게티 코드가 된다. 
따라서 체계적인 프로그래밍 언어의 필요성이 대두된다.

그래서 등장한 3세대 프로그래밍 언어는 절차지향 언어라고 불리는 Pascal 언어와 그 다음 C언어가 등장하게 된다.
절차지향 언어로 몇십년을 버텨오다 이제 프로그램의 크기가 예전과는 상상도 할 수 없을 정도로 커지게 되자 이제는 새로운 패러다임이 필요하게 된다.
바로 객체지향 언어이다(Object oriented language, OOP)
이를 사용하는 언어는 C++, Java, Python, C# 등등 90년대 이후에 생긴 언어들은 대부분 객체지향 언어이다.
물론 C++은 객체지향언어라고 단정짓기에는 어렵다. C++은 템플릿을 이용해서 제너릭한 프로그래밍도 가능하고 모던 C++에 들어서서는 함수형 프로그래밍도 가능하다. 또한 절차지향 프로그래밍도 당연히 가능하다. 따라서 C++은 멀티 패러다임으로 보는 것이 바람직하다.

그렇다면 객체(object)란 무엇인지 알아보자.

위에서 살펴본 Animal구조체를 보면 구조체 정의를 한 뒤 play함수에 전달해줬다.
하지만 이러한 인자전달은 불필요하다.
따라서 이를 변경할 수 있다.
이젠 play함수에 animal을 인자로 주지 않아도 된다.
내가 play하는 것이기 때문에 내 정보를 이미 play함수가 다 알고있기 때문이다.
play함수는 나의 상태를 모두 알고 이에 대한 적절한 처리를 할 수 있다. 즉 animal 은 자신의 상태를 알려주는 변수, 자신이 하는 행동들을 수행한느 함수들로 이뤄졌다고 볼 수 있다.
따라서 객체는 다음과 같이 정의된다.
"변수들과 참고 자료들로 이루어진 소프트웨어 덩어리"
이때 객체가 현실세계에서의 존재하는 것들을 나타내기 위해서는 추상화(abstraction)과정이 필요하다. 컴퓨터 상에서 현실 세계를 100%나타낼 수 없기 때문에 처리할 수 있도록 변환시키는 것이다. 따라서 현실세계의 행위를 함수로 변환해야한다.
객체의 변수와 함수를 각각 인스턴스 변수(instance variable), 인스턴스 메소드(instance method)라고 부른다. 따라서 인스턴스 메소드라는 말을 들으면 객체에 정의되어 있는 함수라고 생각하면 된다.

객체를 그림으로 표현한 것에서 보면 Methods가 Variable을 보호하고 있는 것처럼 묘사된다. 이는 변수들이 외부로부터 보호받고 있기 때문이다. 따라서 외부에서 객체의 instance variable을 변경하지 못하고 오직 instance method를 통해서만 변경이 가능하다는 것이다. 항상 그런것은 아니지만 일반적으로 그렇게 이뤄진다.

이와 같이 외부에서 직접 인스턴스 변수의 값을 바꿀 수 없고 항상 인스턴스 메소드를 통해서 간접적으로 값을 조절하는 것을 캡슐화(Encapsulation)라고 부른다.
겉으로 볼 때는 animal.food += 100; 과 animal.increase_food(100); 의 차이점이 없어보인다.
간단하게 보면 장점은 다음과 같다. "객체가 내부적으로 어떻게 작동하는지 몰라도 사용할 줄 알게 된다."
즉 animal.increase_food(100);을 하면 내부적으로 food 변수값이 100 증가하는 것 뿐만이 아니라 몸무게도 바꿀 수 있고 행복도도 변화가능하고 등등 여러가지 작업이 동시에 일어날 수 있다. 하지만 이러한 함수를 사용하지 않는다면 프로그래머가 이를 하나하나 처리해줘야 한다. 이는 food를 100늘리는 과정에서 정확히 어떤 일이 일어나는지를 파악해야만 처리할 수 있는 아주 귀찮은 문제이다. 따라서 대형 프로젝트에서는 객체를 한 사람이 설계하는 것이 아니기 때문에 이러한 인스턴스 메소드를 활용하게 된다. 따라서 food를 늘리려면 그냥 increase_food를 이용하면 그와 연관된 나머지 작업들은 모두 함수가 알아서 하게 되므로 간편해지는 것이다.

키보드의 경우에도 마찬가지이다. 만약 '키보드의 a를 누른다' 라는 행위는 우리가 컴퓨터에서 어떠한 연산이 이뤄지는지 알 필요가 없다. 따라서 my_computer.keyboard_hit('a') 라는 인스턴스 메소드를 호출하는 것으로 생각하면 된다.

따라서 캡슐화로 인해 얼마나 작업이 편해지는지 알 수 있다.

-클래스
C++에서 객체를 만들어 낼 수 있는 장치가 바로 클래스(Class)이다. 쉽게 말해도 객체의 설계도라고 볼 수 있다.
C++에서 클래스를 이용해서 만들어진 객체를 instance라고 부른다. 따라서 앞에서 다룬 변수와 함수를 인스턴스 변수, 인스턴스 메소드라고 부르는 이유를 알 수 있다.

main함수에서 Animal 클래스의 인스턴스를 생성하였다.
구조체에서 구조체 변수를 생성할 때와 동일하다. 구조체의 경우 앞에 struct 를 명시해야 했지만 class는 그럴 필요 없이 바로 변수 이름만 적어도 된다.
따라서 Animal animal; 만 하면 인스턴스가 생성되는 것이다.
이 Animal 클래스에서는 food, weight라는 변수가 있고, set_animal, increase_food, view_stat이라는 함수들이 있다. 이들을 지칭할 때 각각 멤버 변수(member variable), 멤버 함수(member function)이라고 부른다.

즉 인스턴스로 생성된 객체에서는 인스턴스 변수, 인스턴스 함수, 그리고 그냥 클래스에서는 멤버 변수, 멤버 함수라고 부르는 것이다. 멤버 변수와 멤버 함수는 인스턴스가 만들어져야 실재하게 되는 것이다. 설계도 상에 있다고 해서 아파트가 실제로 존재하는것이 아닌 것처럼 말이다.

클래스에서 멤버 변수를 정의한 부분을 보면, 새로운 키워드가 나온다. private, public 이다. 이를 접근 지시자 라고 한다. 외부에서 이러한 멤버들에 접근을 할 수 있냐 없냐를 정해주는 역활이라 보면 된다. 따라서 private는 외부에서 접근이 불가하고 public은 외부에서 접근이 가능하다. 따라서private키워드 아래에 쓰여진 것은 객체 내에서 보호받고 있다. 즉 private된 것들은 자기 객체 안에서만 접근이 가능하고 외부에서는 접근이 불가하다. 따라서 private된 변수를 변경하려면 public에 있는 함수에서 접근을 해야 한다.
public은 외부에서 이용이 가능하다. 
접근 지시자 키워드 명시를 하지 않았다면 기본적으로 private으로 설정된다. 따라서 처음에 private키워드를 지워도 자동으로private으로 설정이 된다.
만약 멤버 변수들도 public으로 공개하면 구조체처럼 객체 밖에서도 접근이 가능한 형태가 된다.

객체란 무엇인가? : 객체 또는 오브젝트(object)는 클래스에서 정의한 것을 토대로 메모리에 할당된 것으로, 프로그램에서 사용되는 데이터 또는 식별자에 의해 참조되는 공간을 의미한다. 객체 내부는 변수, 자료구조, 함수, 메소드가 될 수 있다. 객체의 설계도는 클래스에 의해 만들어지고 이 객체가 선언되어서 메모리에 할당되기 전 까지는 객제는 존재하지 않는 상태이다. 설계도만 존재하는 상태인 것이다. 절차적 프로그래밍에서는 하나의 객체는 자료나 명령 중 하나만 포함할 수 있다.
하지만 객체지향 프로그래밍에서는 객체는 클래스의 인스턴스이다. 따라서 객체는 자료와 명령을 조합하여 존재한다. 객체가 메시지를 받고 자료를 처리하여 메시지를 다른 객체로 보낼 수 있다.

클래스 : 클래스는 객체의 설계도를 만드는 방식이다. 즉 객체를 만들어 낼 수 있는 장치이다. 이 클래스로 만들어진 객체를 instance(인스턴스)라고 부른다.
인스턴스 : 클래스로 만들어진 객체를 인스턴스라 부른다.
인스턴스 변수 : 인스턴스에 존재하는 변수
인스턴스 함수 : 인스턴스에 존재하는 함수이며 이를 통해 변수로 접근이 가능하면 인스턴스 메소드라 정의한다.
멤버 변수 : 클래스 내부에 존재하는 변수(실재x)
멤버 함수 : 클래스 내부에 존재하는 함수

-함수의 오버로딩(Overloading)
C에서는 하나의 이름을 가지는 함수가 딱 1개만 존재할 수 밖에 없다. 하지만 C++에서는 같은 이름을 가진 함수가 여러개 존재해도 된다. 따라서 함수의 과부하, 즉 함수의 오버로딩이 발생할 수 있게 되었다.
C++은 같은 이름을 가진 함수를 호출했을 경우 사용하는 인자를 보고 결정을 내린다.
고전적인 C의 컴파일러는 오류가 발생하지만 C++에서는 인자가 다르면 다른 함수라고 판단하기 때문에 오류가 발생하지 않는다.
함수를 오버로딩하는 과정은 다음과 같다.
1. 자신과 타입이 정확히 일치하는 함수를 찾는다.
2. 정확히 일치하는 타입이 없으면 아래의 형변환을 통해 일치하는 함수를 찾는다.
char, unsigned char, short는 int 로 형변환등등
Float는 double 로 형변환
3. 좀 더 포괄적인 형변환을 통해 일치하는 함수를 찾는다.
4. 유저 정의된 타입 변환으로 일치하는 것을 찾는다.
만약 위의 과정을 거쳐도 일치하는 함수를 찾을 수 없거나 같은 단계에서 두 개 이상 일치하는 경우에는 모호하다(ambiguous)라고 판단해서 오류가 발생한다.

만약 double이 오버로딩 걸린 경우 double은 3단계에서 char,int로 형변환이 모두 가능하므로 두 개 이상의 일치가 발생해서 오류가 발생하게 된다.

클래스 내부에서 함수의 정의만 선언하고 함수의 몸통은 외부에 존재하는 경우가 있다. 이는 클래스 내부에서 함수의 몸통이 존재하게 되면 클래스의 내부가 복잡해지는 상황을 막기위해 이러한 방식을 사용한다. 따라서 클래스 내부의 함수를 만들려면 반환형 클래스이름::함수이름 을 이용하여 선언하면 된다.
만약 일반적으로 함수를 선언하는 것 처럼 하게 되면 그 함수는 클래스의 멤버함수가 아니라 그냥 일반적인 함수가 되어버린다. 따라서 간단한 함수를 제외하면 대부분의 함수들은 클래스의 바깥에서 정의하게 된다. 클래스의 내부는 최대한 깔끔하게 유지하는것이 바람직하다.

생성자(constructor)
: 기본적으로 "객체 생성 시 자동으로 호출되는 함수" 라고 볼 수 있다.
이때 자동으로 호출되면서 객체를 초기화하는 역활을 담당한다.
이 생성자는 객체를 초기화하는 역활을 하기 때문에 리턴값이 존재하지않는다.

생성자 선언 방식은 다음과 같다.
클래스 이름 (인자)
{
	초기화 내용
}
이 생성자를 사용하면 생성 후 초기화를 숙지하지 못했더라도 이 문제를 언어 차원에서 해결할 수 있다.

명시적 방법으로도 생성자의 호출이 가능하지만 암시적 방법이 가능하므로 가능하면 이를 선호하는 편이다.

디폴트 생성자(Default Constructor)
: 만약 SetDate함수를 이용해서 객체를 초기화 시킬 때 생성자를 명시하지 않았다.
즉 처음에 생성자 정의를 하지 않고 단순히 인스턴스 선언만 했을때도 생성자가 호출되는가? 그렇다.
이러한 경우를 디폴트 생성자라고한다.
이는 인자를 하나도 가지지 않는 생성자이다. 클래스에서 사용자가 어떠한 생성자도명시적으로 정의하지 않았을 때 컴파일러가 자동으로 추가해주는 생성자이다. 
이 디폴트 생성자를 정의하는 것도 가능하다.

오버로딩이란 인자를 통해 동일한 이름의 함수 중에서 어떤 함수를 사용할지 판단하는 것을 의미한다. 정확하게 일치하는 자료형이 없다면 자료형을 형변환을 해가면서 판단을 내린다.

1단계
: 자신과 타입이 정확히 일치하는 함수를 찾는다.

2단계
: 형변환을 통해 일치하는 함수를 찾아본다.
char, short는 int로 변환, Float는 double로 변환 Enum은 int로 변환

3단계
: 포괄적인 형변환을 통해 일치하는 함수를 찾아본다.
float > int, Enum > double, 0 > 포인터 > void포인터

4. 유저 정의된 타입
> 여기서 찾지 못하면 ambiguous

즉 int ,double은 서로 형변환이 불가하다. 따라서 인자에서 int , double이 동시에 다르면 오류가 발생한다.

생성자 : 객체 생성시 자동으로 호출되는 함수
>자동으로 호출되면서 객체(instance)를 초기화하는 역활

암시적 방법 : Date day(2011, 3, 1)
명시적 방법 : Date day = Date(2012, 3, 1)

생성자도 역시 함수이기 때문에 함수의 오버로딩에 적용이 가능하다.

struct 와 class 차이
>>구조체와 클래스의 차이
먼저 연관있는 데이터를 하나로 묶는다는 기본 개념은 동일

struct : 기본적으로 외부에서 접근이 가능하다.
class : 기본적으로 외부에서 접근이 불가능하다. > 함수를 이용하여 접근해야한다. 이러한 함수 또는 다른 방법을 외부 접근 지시자 라고 한다.

구조체와 클래스를 구분하여 사용하는 방법 : 구조체는 스택 메모리에 바로 할당이 된다. 클래스는 인스턴스를 생성할 때마다 힙에 메모리를 할당한다. 만약 많은 양의 변수를 가져야 한다면 구조체보다는 클래스가 유리하다. 구조체에 많은 변수를 할당하면 제한적인 크기를 가진 스택이 넘쳐서 스택 오버플로우가 발생할 수 있다.
반면 참조형식인 클래스는 값들을 가리키는 주소값만 저장하므로 유리하다.

즉 변수의 크기가 작거나, 수명이 짧고, 자주 할당되는 객체는 구조체로 만들어주는 것이 좋다. 하지만 구조체는 상속이 불가능하므로 고려해야한다.

void PrintNumMeets();
: 모든 점들을 잇는 직선들 간의 교점의 수를 출력하는 함수

for 이중중첩을 통해 모든 점들의 직선을 나타낸다.
직선이 정해지면 그 직선을 형성하는 두 점을 제외한 나머지 점들을 for문으로 돌려보면서 구한다?
>>시간복잡도 증가 O
따라서 시간복잡도를 줄이기 위해 먼저 직선의 방정식을 만들어서 배열에 초기화 시킨다.
직선의 방정식 계수 a,b,c와 그 직선을 만든 좌표의 인덱스 두 개를 초기화한다.
위의 방법에서 직선의 방정식을 만드는데는 for문이 이중으로만 중첩되면 가능하다.
그 다음 for문을 3번 중첩하여 점들이 직선의 방정식을 기준으로 같은 영역에 존재하는지, 또는 다른 영역에 존재하는지를 판단할 수 있다.

위에서 정의한 함수를 테스트하는데에는 난수를 사용하는 방법이 합리적이다. 따라서 Cpp에서 난수를 정의한다. C에서는 의사난수를 이용하였지만 C++에서는 라이브러리에서 난수를 제공한다.
random 라이브러리를 include하면 난수의 사용이 가능해진다.
먼저 난수 생성을 위해 시드를 얻어야 하는 것은 의사난수와 동일하다. 따라서 random_device 클래스의 인스턴스를 선언한다.
그 다음 난수를 생성하는 엔진은 메르센-트위스터 엔진을 사용하므로 mt19937 gen(rd()); 코드를 통해 엔진을 초기화 해준다.
여기서 클래스는 mt19937 이고 gen이라는 인스턴스를 선언한 것이다.
이제 완전한 난수를 생성하기 위해서는 균등분포의 정의가 필요하다. 따라서 난수로 나오려는 자료형을 정함과 동시에 난수로 나오는 값들의 범위도 균등분포로 정한다.
uniform_int_distribution<int> dis(-10, 10)
>>-10부터 10까지 난수의 범위를 한정하겠다는 의미
<자료형>
이제 난수는 dis(gen)을 통해 생성된다. 
이를 테스트 변수에 넣어주면 자동으로 난수가 생성되어서 테스트케이스를 만드는 모습을 볼 수있다.


4.3 스타크래프트를 만들자

마린을 구현할 클래스를 만든다.
그리고 그 클래스를 이용하여 만든 인스턴스들이 각각의 마린이 된다.
어떠한 객체의 내부적 성질, 상태 등에 관련된 변수들은 모두 private 범주에 두고, 그 객체가 외부에 하는 행동들은 함수로써 구현하여 public에 두면 된다.
즉 마린이 가진 성질, 상태는 위치, 체력, 데미지, 죽음 등이 있고, 마린이 외부에 하는 행동은 이동, 공격, 피격, 상태보기 등이 있다.

실제에서 수십마리의 마린들이 존재한다면 각각의 마린들에게 이름을 붙이기도 힘들고 사용자가 몇 마리의 마린들을 만들지도 컴파일 시점에 정해버리는게 아니기 때문에 수십개의 마린을 만들수는 없다. 따라서 마린들을 배열로 정해버린다.

따라서 배열로 선언한 뒤 new 연산자를 통해 메모리를 동적 할당한다.

-new 와 malloc의 차이
malloc은 메모리를 동적 할당하는 것이 목적이기에 초기값을 지정할 수 없지만 new는 메모리를 동적 할당하는 것과 동시에 초기화가 가능하다. 즉 생성자를 자동으로 호출한다는 것이다. 즉 가장 큰 차이점은 생성자를 호출하냐 안하냐의 차이이다.
또한 malloc은 함수이지만 new는 연산자이다. 물론 new연산자는 내부적으로 malloc을 통해 구현되어있다.

동적으로 할당한 메모리는 언제나 해제해줘야 한다.
delete를 통해 해제한다.

만약 delete를 통해 할당되었던 메모리를 해제하지 않으면 메모리 누수(memory leak)가 발생한다. 그렇다면 메모리를 할당할 때 자동으로 초기화 시키는 생성자처럼 자동으로 소멸될 때 호출되는 함수가 있다면 어떨까. 이것이 바로 소멸자(Destructor)이다.
소멸자 함수는 반환형이 존재하지 않으며 name이 char의 배열로 동적할당 되었기 때문에 delete가 아니라 delete[] 로 배열을 모두 해제해 주어야 한다.
만약 []를 쓰지 않으면 완전하게 해제되지 않는다.

b는 함수의 지역객체이므로 시행되고 함수가 종료될 때 소멸자가 호출된다.
객체가 다른 부분에 영향을 미치지 않도록 소멸자의 역활이 필수적이다.

소멸자도 디폴트 소멸자가 존재한다. 물론 아무런 작업도 수행하지 않는다.
만약 소멸자가 필요없다면 소멸자를 따로 쓸 필요가 없다.

-복사 생성자(copy constructor)
Photon_Cannon(const Photon_Cannon& pc); 
>>복사생성자의 표준적인 정의이다. const 를 붙여서 복사를 해오는 출처를 변경이 불가하게 만든다. 그리고 레퍼런스를 통해 가져오는 인수를 동일하게 만든다.
즉 이를 일반화 시키면
Class :: T(const T& a); 와 같다.
다른 T의 객체(인스턴스) a를 상수 레퍼런스로 받는다는 의미이다. 새롭게 초기화하는 인스턴스 변수들에게 복사만 가능하다.
함수 내부에서 받은 인자의 값을 변화시키는 일이 없다면 꼭 const를 사용한다.

pc1은 int x, int y를 인자로 가지는 생성자가 오버로딩 되었고 pc2의 경우 인자로pc1 을 전달했으므로 복사생성자가 호출되었다.
Photon_Cannon pc3 = pc2;
라는 코드는
Photon_Cannon pc3(pc2);
와 동일한 코드로 해석된다.(cpp컴파일러에 의해)
위의 코드를 사용하면 상당히 직관적으로 보이는 코드 작성이 가능해진다.
다만 중요한 것은 복사 생성자는 오직 '생성'시에만 호출이 되므로
Photon_Cannon pc3;
pc3 = pc2; 
라는 문장은 복사 생성자가 호출되지 않는다.

간단한 클래스의 경우에는 복사 생성자를 정의하지 않더라도 기본적으로 디폴트 복사 생성자를 통해 복사가 가능하다.

디폴트 소멸자의 경우에 char* name으로 선언된 코드가 포함된 경우, 복사된 인스턴스들은 모두 name도 같은 값을 갖게 된다. 즉 name이 위치한 주소값을 모든 인스턴스들이 같은 주소를 가리키게 된다는 것이다. 
물론 같은 주소값을 두 개 이상의 포인터가 가리킨다는 점은 크게 문제가 되지 않는다. 하지만 소멸자가 실행되면 그때 문제가 발생한다.

생성되었던 인스턴스들이 파괴되면서 소멸자를 호출하게 된다. 이때 pc1이 파괴되면 한 번 해제된 메모리는 다시 해제될 수 없으므로 만약 두 개 이상의 소멸자가 같은 주소를 해제하려 하면 해제된 메모리에 접근했으므로 런타임 오류가 발생하게 된다. 

이러한 문제를 막으려면 복사 생성자에서 해결해야 한다. name을 그대로 복사하는 것이 아닌,  문자열만 복사하는 것이다. 즉 다른 메모리에 동적 할당을 해서 그 내용만 복사하는 것이다. 이렇게 메모리를 새로 할당해서 내용을 복사하는 것을 깊은 복사(deep copy)라고 한다. 그리고 그냥 단순하게 대입만 하는 복사를 얕은 복사(shallow copy)라고 한다. 컴파일러가 생성하는 디폴트 복사 생성자의 경우 깊은 복사를 할 수 없고 얕은 복사만 가능하다. 따라서 이러한 깊은 복사가 필요한 경우는 사용자가 직접 복사생성자를 코딩해야한다.

스타크래프트에서 캐논을 생성할 때를 보면 hp, shield와 같은 변수들은 얕은 복사를 진행해서 복사를 하지만 name의 경우는 char* 로 자료형이 구성되어 있으므로 따로 메모리를 동적 할당해서 복사를 진행해줘야 한다. 그러면 소멸자도 메모리 해제시 서로 다른 메모리를 해제하게 되므로 서로 충돌이 일어나지 않는다.

*C언어에서는 문자열을 char 자료형 배열로 다루지만, C++에서는 STL에서 std::string이라는 문자열 클래스를 제공하니 이를 이용하는게 바람직하다.

4-3강

기존의 생성자를 만들 때 함수 본체안에 코드를 작성했다.
생성자에 새롭게 코드를 작성할 수 있다.
즉 멤버 변수들의 초기화 작업을 함수 안에서 굳이 하지 않아도 된다.
생성자 이름 뒤에 : 를 쓰고 초기화 작업을 진행하는데 이것을 초기화 리스트(initializer list)라고 부르며, 생성자 호출과 동시에 멤버 변수들을 초기화 해주는 역활을 한다.

이때 멤버 변수에 값을 초기화 할 때 기존에는 변수 이름 = 대입할 값; 이라는 코드를 작성했지만 이렇게 초기화 리스트를 작성할 때는 변수이름(대입할 값) 이라는 코드를 작성하면 된다.

멤버 초기화 리스트의 일반적인 꼴은 다음과 같다.
(생성자 이름) : var1(arg1), var2(arg2) {}
var은 클래스의 멤버 변수들을 지칭한다. arg는 초기화할 값을 지칭한다. 이때 var 의 값과 arg의 이름이 같아도된다. 즉 바깥쪽의 변수는 컴파일러에 의해 무조건 멤버 변수를 지칭하게 된다. 그리고 안쪽의 변수는 컴파일러에 의해 인자로 받은 변수를 지칭하게 된다.

그렇다면 왜 초기화 리스트를 사용하는가?
>>초기화 리스트는 인스턴스를 생성함과 동시에 멤버 변수들을 초기화를 진행한다. 이는 인스턴스를 생성하고 함수 본체에서 변수를 초기화 할 때는 생성을 먼저하고 변수 초기화를 진행하지만 초기화 리스트는 그 과정을 한 번에 진행하기 때문에 간결하게 코드를 작성할 수 있다.
즉 이를 기존의 변수 선언을 예시를 들어 비교하면
int a;
a = 10;
이라는 코드를
int a = 10;
이라는 코드로 바꾼 것과 같다. 

생성과 동시에 초기화를 시켜야 하는 것들은
1. 레퍼런스
2. 상수
가 존재한다.
따라서 이러한 것들을 클래스 내부에 넣고 싶다면 이들을 무조건 초기화 리스트를 이용하여 초기화를 해줘야 한다.

마린의 공격력과 같은 값은 절대로 변경이 되면 안되기 때문에 const 상수를 통해 초기화를 진행한다. 이러면 생성자에서 초기화 리스트를 통해 호출이 되고 초기화를 진행하면 절대로 변경 될 일이 없게 된다.
만약 변경을 하려해도 컴파일 오류가 발생하므로 효율적으로 오류를 발견할 수 있다.

default_damage에 default_damage를 초기화 하는데 이는 클래스 내부에 이름이 같은 것이 있어서 중복될 걱정을 피할 수 있다.

만들어진 마린의 수를 알아내기 위한 코드를 짜본다.
일반적으로 두 가지 방법이 있다.
1. 어떠한 배열에 마린을 보관해 놓고, 생성된 마린의 수를 배열의 크기를 계산하여 센다.
2. 어떤 변수를 만들어서 마린이 생성될 때 마다 1을 추가하고 소멸시에 1을 뺀다.

첫번째는 크기가 자유자재로 변경되는 배열을 만들어야 하므로 한계가 존재한다.
변수를 정의한다면 크기에 조금 더 자유로워진다.
하지만 만약 전역 변수로 이를 선언한다면 프로젝트의 크기가 커질 수 있다. 또한 프로그래머의 실수로 오류가 날 가능성이 크다(스파게티코드)
C++에서는 이러한 문제를 간단하게 해결할 수 있다. 전역변수 같지만 클래스 하나에만 종속되는 변수 static 멤버 변수이다.
C언어에서 어떠한 함수의 static 변수가 지역 변수들 처럼 함수가 종료될 때 소멸되는 것이 아니라 프로그램이 종료될 때 소멸되는 것 처럼, 어떤 클래스의 static 멤버 변수의 경우, 멤버 변수들 처럼 객체가 소멸될 때 소멸되는 것이 아니라 프로그램이 종료될 때 소멸하는 것이다.

또한 이러한 static 변수의 경우 클래스의 모든 인스턴스들이 공유하는 변수이므로 각 인스턴스 별로 따로따로 존재하는 멤버 변수와 달리 모든 인스턴스들이 하나의 static 멤버 변수를 공유하게 된다.

클래스 내부에서 static 변수를 초기화 시키는 경우는 불가능하다. 이는 const static 변수일 때만 가능하다. 하지만 마린의 수는 변경해야하므로 const로 선언할 필요가 없다.

static 함수는 (객체).(멤버 함수) 처럼 호출하는 것이 아니라 (클래스)::(static 함수) 형식으로 호출을 하게 된다. 왜냐하면 어떠한 함수도 이 static함수를 소유하고 있는 것이 아니기 때문이다.

this라는 것은 C++언어차원에서 정의되어 있는 키워드이다. 이는 객체 자신을 가리키는 포인터의 역활을 한다. 즉 모든 멤버 함수 내부에서는 this 키워드가 정의되어 있다. 그리고 클래스 안에서 정의된 함수 중에서 this 키워드가 없는 함수는 static함수 뿐이다. static함수는 멤버 함수가 아니므로

레퍼런스를 리턴한다는 것은 어떤 의미인가? 레퍼런스는 어떤 변수의 다른 별명이다. 
레퍼런스를 반환했는데 좌측값이 변수이면 아무 소용이 없다.
여기서 레퍼런스를 반환하는 함수를 좌측에 놓고 우측에 value를 대입해도 맞는 코드가 되는데 이는 "레퍼런스를 리턴하는 함수는 그 함수 부분을 리턴하는 원래 변수로 치환해도 된다." 라는 말이 성립하기 때문이다.
즉 a.access_x() = 3; 이라는 코드는 a.x = 3과 동일한 코드가 된다.
다만 a.get_x() = 3; 이라는 코드는 오류가 발생한다. 이는 함수가 값을 리턴하기 위해 임시 객체에 값을 복사하는데 임시객체는 곧바로 사라지기 때문이다.
즉 call by value는 임시 객체를 생성하고, call by reference는 레퍼런스를 가져와서 변수이름으로 치환이 가능하다는 장점이 있다.

C++에서는 변수들의 값을 바꾸지 않고 읽기만 하는, 마치 상수 같은 멤버 함수를 상수 함수로써 선언이 가능하다.
상수 함수는 아래와 같은 형태로 선언을 한다.
(기존 함수의 정의) const;
따라서 마린의 데미지를 리턴하는 함수는 읽기만 하는 함수이므로
int Marine::attack() const { return default_damage; }
라고 선언할 수 있다.
이러한 const 함수 선언을 이용하면 다른 프로그래머에게 값을 바꾸지 않는 함수라고 명시가 가능해진다는 장점을 가진다.
상수함수 내에서 호출할 수 있는 함수는 다른 '상수 함수'만 가능하다.

대부분의 경우, 클래스를 설계할 때 멤버 변수들은 모두 private에 넣고 이 변수들의 값에 접근하는 방법으로 구현한다. 따라서 멤버 함수들은 public에 존재하기 때문에 이 함수들을 이용해서 값을 리턴받는 형식을 많이 사용한다.
이때 const 함수를 사용하면 함부로 변수에 접근하는 것을 막을 수 있고 그 값을 자유롭게 구현이 가능하다.

4-5 강

문자열 클래스에는 대표적으로 두 가지의 데이터가 필요하다.
1. 문자열 데이터가 저장된 공간을 가리키는 포인터
2. 문자열 데이터의 길이
왜 인스턴스에 문자열 데이터를 배열로 직접 보관하는 것이 아니라 저장된 공간을 가리키는 포인터를 보관하는가? 
>>나중에 문자열 데이터의 크기가 바뀔 때, 저장된 공간을 가리키는 방식으로 하면 그 메모리를 해제하고 다시 할당해서 메모리 누수를 막을 수 있지만, 직접 보관하면 그럴 수가 없기 때문이다.
또한 문자열의 길이를 멤버 변수로 보관하는 이유는 사용할 일이 굉장히 많기 때문이다. 즉 사용할 때마다 그 길이를 구하는 것은 굉장히 불필요한 일이다.

문자열 클래스에서는 생성자가 총 3개 나온다.
1. 문자 하나를 인자로 받아서 생성하는 생성자
2. 문자열을 인자로 받아서 생성하는 생성자
> 이 경우 인자는  const char* str로 받는다. 받아서 생성만 하므로 읽기 전용인 const로 선언
3. 복사 생성자
> 이 경우 인자는 const (클래스 명)& str 로 받는다. 인자로 레퍼런스를 받으면 오버로딩으로 복사하기 위해서이다.

C형식의 문자열은 널 문자로 끝나야만 문자열의 종료를 확인할 수 있었다. 하지만 이제 클래스 내부에서 멤버 변수로 문자열의 길이를 저장할 수 있어서 더 이상 널 문자로 문자열의 종료를 확인할 필요가 없다. 따라서 이제는 널 문자를 이용한 문자열의 종료를 확인하지 않는다.
따라서 실제 문자에만 해당하는 내용을 string_content에 담는다.

총 3개의 생성자를 정의하였고 string_content를 동적 할당(new)로 처리하였기 때문에 반드시 소멸자에서 이를 동적 해제해줘야 한다.(delete[])
이것은 클래스의 큰 장점이다. 기존에 C언어에서는 구조체 같은 것으로 문자열을 구현했다면 이를 일일이 해제해줘야 했는데 이제 클래스를 사용하면 그런것은 신경쓰지 않고 사용이 가능하다.

문자열의 길이를 반환하는 함수는 단순하게 string_length를 반환하면 된다. 다만 이때 값을 변경하는 함수가 아니므로 상수 함수로 선언하는 것이 바람직하다.

-assign 함수
: 지정하다 라는 뜻을 가진 함수로 '='과 동일한 역활을 하게 된다.
인자로 입력받는 문자열의 크기가 기존의 문자열보다 작다면 굳이 동적 할당을 통해 메모리를 다시 할당할 필요가 없다. 따라서 그 경우에는 그냥 복사하게 된다.

초기에 큰 메모리를 할당하고 있다가 짧은 문자열로 복사하고 다시 긴 문자열로 복사할 때 할당된 메모리가 줄어들었다가 다시 크게 늘어나는 비효율적인 작업을 하게 된다.
이때 메모리를 동적 할당할 때 판단 기준을 문자열의 길이가 아니라 실제 메모리의 용량으로 판단하면 이러한 비효율적인 작업을 줄일 수 있다.
따라서 memeory_capacity라는 새로운 변수를 추가한다.

문자열에서 임의의 위치의 문자를 리턴하는 함수를 추가한다.
C언어에서는 구조상 배열의 범위를 벗어나는 위치에 대한 문자를 요구하여도 이를 처리할 수 밖에 없었다. 하지만 C++의 경우 특정위치의 문자를 얻는 것도 함수로 만들어서 올바르지 않는 위치에 대한 문제를 해결할 수 있게 되었다.

지금까지 직접 제작한 문자열 클래스의 기본적인 함수들을 제작하였다.
1. 문자 혹은 문자열에서 생성할 수 있는 생성자와 복사 생성자
2. 문자열의 길이를 리턴하는 함수
3. 문자열 대입 함수
4. 문자열 메모리 할당 함수 및 현재 할당된 크기를 알아오는 함수
5. 특정 인덱스의 문자를 리턴하는 함수

insert함수의 작업에서 만약 작은 문자들을 집어넣는 명령을 많이 수행한다고 생각해보자. 그렇다면 긴 문자열은 이미 많은 메모리를 할당하고 있는데 이 작은 문자를 넣기 위해서 계속해서 할당된 메모리를 해제하고 다시 할당해야한다. 이는 굉장히 낭비가 된다. 따라서 이를 해결하기 위해 기본적으로 잦은 할당/해제를 피하기 위해 미리 메모리를 할당해놓기가 있다.
메모리를 미리 할당할 경우, 현재 메모리 크기의 두 배 정도를 미리 할당해 놓으면 된다.
즉 새로 할당해야 할 메모리의 크기가 현재의 두 배 이하라면 두 배에 할당하는 메모리를 할당하는 것이다. 물론 새로 할당할 메모리의 크기가 현재의 두 배 이상이라면 그에 맞게 할당하면 된다. 이는 작은메모리를 잦은 빈도로 추가해야 할 경우를 대비하는 것이기 때문이다.
이러한 기법은 C++에서 동적 할당 메모리를 처리할 경우 매우 빈번하게 사용되는 기법 중 하나이다.

erase 함수
매개변수로 삭제를 시작할 위치와 삭제할 문자의 개수를 전달받는다. 만약 삭제를 시작할 인덱스가 문자열 범위 밖이거나 삭제할 문자의 개수가 0이하면 그대로 return *this를 통해 아무 작업도 수행하지 않는다.
아니라면 반복문을 통해 loc + num 인덱스부터 차례대로 string_length까지 끌고온다. 그리고 string_length를 삭제한 길이만큼 줄인다. 실제로 끌고오는 과정에서 뒤의 문자들을 초기화하진 않았지만 string_length를 줄였기 때문에 이제 전혀 신경쓰지 않는 범위가 되었으므로 필요가없다.

find 함수
insert 와 erase는 연산 시간이 크게 오래 걸리지는 않는다. 하지만 find 는 문자열의 크기가 매우 크다면 연산이 매우 오래걸릴 수도 있다.
따라서 이러한 검색을 수행하는 알고리즘은 수 없이 많이 존재한다.
하지만 상황에 따라서 좋은 성능을 발휘 할 수 있게 알맞은 알고리즘을 활용해야 한다.
예를 들어 짧은 문자열을 검색하는 알고리즘과 긴 문자열을 검색하는 알고리즘은 서로 최적화 된 자료구조가 필요하다. 따라서 클래스의 사용 목적이 명확해서 그 알고리즘이 좋은 성능을 발휘 할 수 있는 경우에만 사용한다.
다만 이번에는 가장 간단한 방식으로 find 알고리즘을 구현한다.

int find(int find_from, MyString& str) const; 를 구현한 뒤 나머지 오버로딩 함수들을 구현한다.
find_from 에서 부터 시작해서 가장 첫 번째 str의 위치가 나오는 곳을 리턴한다. 만약 str 이 문자열에 포함되어 있지 않다면 -1을 리턴한다. 이러한 방법으로 어떤 문자열 내에 있는 모든 str들을 찾을 수 있는 for문을 생각할 수 있다.

compare 함수
문자열 간의 크기를 비교하는 함수. 사전식의 크기를 의미한다.
사전순으로 비교를하고
std::min 함수를 통해 두 문자열 중 길이가 작은 것을 이용해서 for 문 탐색을 진행하지만 , 만약 문자열 길이가 그 길이까지의 탐색에서 같은 경우(ex. abc 와 abcd)
이 경우는 길이가 긴 것이 사전적으로 더 뒤에 오게 된다. 따라서 문자열 길이 비교를 한 번 더 수행한다. 문자열 길이가 같다면 두 문자열이 서로 같은 문자열이므로 0을 반환한다.
여기서 사용한 std::min 함수는 iostream 라이브러리를 include하면 사용이 가능하다. std::max도 가능

지금까지 만들어 본 문자열 클래스는 다음과 같은 기능을 제공한다.
1. 문자 c 혹은 C형식의 문자열 str에서 생성할 수 있는 생성자와 복사 생성자
2. 문자열의 길이를 리턴하는 함수
3. 문자열 대입 함수
4. 문자열 메모리 할당 함수 및 현재 할당된 크기를 알아오는 함수
5. 특정 위치에 문자를 리턴하는 함수
6. 특정 위치에 특정 문자열을 삽입하는 함수
7. 특정 위치에 특정 개수의 문자를 지우는 함수
8. 특정 위치를 시작으로 특정 문자열을 검색하는 함수
9. 두 문자열을 사전식 비교하는 함수


4-6강 클래스의 explicit 과 mutable 키워드

explicit
클래스의 생성자가 인수로 const char* str 를 받을 때, 만약 인자가 그냥 "abc"가 전달된다면 이는 컴파일러가 알아서 MyString("abc") 로 변환한다. 이는 암시적 변환(implicit conversion)이라고 한다. 하지만 이러한 암시적 변환이 항상 편리한 것만은 아니며 우리가 예상하지 못한 경우에서 암시적 변환이 일어날 수도 있다.
따라서 이러한 문제를 해결하기 위해 explicit 키워드가 존재한다. 이 키워드를 통해 컴파일러에게 원하지 않는 암시적 변환을 하지 말라고 명시할 수 있다.

mutable
기존에 const 멤버 함수는 함수 내부에서 멤버 변수들의 값을 바꾸는 것이 불가능하다고 배웠다. 하지만 멤버 변수를 mutable로 선언하면 const 함수에서도 이 값을 변경이 가능해진다.
그런데 이렇게 할 바에는 그냥 const 함수를 사용하지 않으면 되지 않을까? 라는 의문이 생긴다.
클래스의 멤버 함수들은 "이 객체는 이러한 이러한 일들을 할 수 있습니다." 라는 의미를 가진다. 그리고 멤버 함수를 const 선언을 붙여서 선언하는 의미는 "이 함수는 객체의 내부에 영향을 주지 않는다" 이다. 대표적인 예로 읽기 작업을 수행하는 함수들이 const 선언을 붙여서 나온다.
하지만 대부분의 경우 의미상 상수 작업을 하는 경우, 실제로도 상수 작업을 하게 된다.

서버 프로그램을 예로 들어본다.
유저의 아이디를 받으면 그 유저를 조회해서 그 유저의 정보를 리턴하는 함수가 존재한다고 해보자. 그렇다면 이 함수는 데이터베이스를 업데이트하지도 않고, 무언가 정보를 수정하는 작업도 하지 않기 때문에 const 함수로 선언된다.
하지만 보통 데이터베이스는 그 크기가 매우 방대하기 때문에 데이터를 요청 후 받아오는 작업은 시간이 꽤 오래 걸리게 된다. 따라서 서버에서는 캐쉬(cache)를 만들어서 자주 요청되는 데이터를 굳이 데이터베이스까지 가서 찾지 않아도 메모리에서 빠르게 조회가 가능하게 만든다.
물론 캐쉬는 모든 유저들의 정보를 포함하는 것이 아니다. 따라서 캐쉬에 정보가 없다면 데이터베이스로 이를 요청해야한다. 그러면 다음에는 캐쉬에서 빠르게 정보를 받을 수 있게된다.
만약 캐쉬가 가득차면 오래된 정보부터 지운다(queue)
따라서 유저정보를 조회하는 함수에 캐쉬에 업데이트하는 작업을 넣어야하는데 이 함수는 원래 const 목적으로 만들어진 함수이므로 이 작업이 불가능하다. 그렇다고 이 함수에서 const 선언을 뺴버리는 것도 함수의 목적과는 맞지 않는다. 따라서 이러한 경우에 캐쉬 멤버변수에 mutable선언을 이용하여 작업을 수행할 수 있게 변경한다.

따라서 위와 같은 키워드들은 코드를 보다 유연하게 만들어주는 역활을 한다.

5-1강 연산자 오버로딩

기존에 C언어에서는 문자열을 가지고 연산을 한다는 것은 불가능했다.
하지만 C++에서는 사용자 정의 연산자를 사용이 가능하다. 
기존에 같은 이름의 함수를 인자만 다르게 디자인 한 것을 '함수를 오버로딩 했다'라고 부른 것 처럼 기본 연산자들을 직접 사용자가 정의한 것을 연산자를 오버로딩 했다고 한다.
따라서 기본 연산자를 설계한 클래스에 맞게 직접 사용하는 것을 이러하게 부른다.

MyString 의 '==' 연산자 오버로딩
먼저 연산자 오버로딩을 하려면, 다음과 같이 오버로딩을 원하는 연산자 함수를 제작한다.
(리턴 타입) operator(연산자) (연산자가 받는 인자)
따라서 이를 사용하면 코드는 다음과 같다.
bool operator==(MyString& str);
이렇게 적으면 코드는 다음과 같이 변환된다.
str1 == str2 >>> str1.operator==(str2)
그리고 그 결과값을 리턴하게 되는 것이다. 
따라서 MyString 에서 만든 compare함수를 사용해보면 
bool MyString::operator==(MyString& str)
{
     return !compare(str); // str 과 같으면 compare에서 0을 리턴한다. 따라서 !을 사용해서 변환
}
이러한 !연산자를 NOT연산자라 부른다.

복소수(complex number)클래스 만들기
C++ 표준 라이브러리에 std::complex가 정의되어 있어서 굳이 만들 필요는 없다.
만약 연산자의 오버로딩을 모른다고 가정하고 Complex 클래스를 구성해본다.
그렇다면
a + b / c + d;
라는 코드를 
a.plus(b.divide(c)).plus(d);
라고 표현해야한다.
이는 가독성이 매우 떨어지고 무슨 작업을 하려는지 쉽게 이해하기 어렵다.

따라서 연산자 오버로딩을 사용한다. plus 를 operator+ 로 , divide를 operator/로 등등 바꾸면 단순히 코드를 연산자를 이용해서 작성해도 컴파일러가 알아서 변환시켜서 처리하기 때문에 속도나 다른 면의 어떠한 차이가 존재하지 않으면서도 뛰어난 가독성과 편리함을 얻을 수 있다.

만약 연산자 오버로딩을 정의할 때 리턴값 타입을 레퍼런스로 정의하면 다음과 같은 문제가 발생하게 된다.
Complex a = b + c + b;
>> 처음에 b + c 에서 레퍼런스를 리턴받으므로 b = b + c 라는 것으로 치환된다. 따라서 다음에 할 연산인  + b 가  + (b + c)가 되어버리는 결과가 나타난다.
따라서 이러한 문제를 해결하기 위해서는 반드시 사칙연산의 경우에 값을 리턴해야하만 한다.(레퍼런스 x)
인자들의 값이 변화하지 않겠다는 확신이 들면 반드시 const 선언을 하는 습관을 들이자.
또한 객체 내부의 값을 변화시키지 않는 멤버 함수이면 반드시 const 선언을 하자

대입 연산자 함수
대입 연산자 함수는 위에서 알아본 사칙연산 연산자와는 다르게 값이 아니라 레퍼런스를 리턴한다. 
즉
Complex& operator=(const Complex& c);
이라는 코드로 작성한다.
만약 a = b = c;
라는 코드에서 b = c; 가 b를 리턴해야만 a = b; 가 성공적으로 수행되는데
만약 값을 리턴한다면 불필요한 복사가 나타나게 된다.

그런데 굳이 operator= 를 만들지 않더라도 그냥 컴파일 하면 잘 작동한다.
그 이유는 복사 생성자를 다룰 때, 디폴트 복사 생성자가 있었던 것 처럼
컴파일러 차원에서도 디폴드 대입 연산자(default assignment operator)를 지원하고 있기 때문이다.
따라서 디폴트 대입 연산자 역시 얕은 복사를 수행한다.(주소가 같음)
만약 깊은 복사가 필요한 클래스의 경우 사용자가 스스로 대입 연산자 함수를 꼭 만들어서 사용해줘야 한다.

아래의 코드의 차이점
1. Some_Class a = b;

2. Some_Class a;
a = b;

1번 코드는 Some_Class 라는 클래스의 인스턴스인 a의 복사 생성자가 호출되는 것이다
2번 코드는 Some_Class 라는 클래스의 인스턴스인 a의 기본 생성자가 호출되고, 그 다음 대입 연산자 함수가 실행되어 값을 대입하는 것이다. 따라서 두 문장은 비슷해 보여도 완전히 다른 문장이 되어버린다.

위의 사칙연산 함수들을 이용해서 +=, -= 등을 구현할 수 있다.
마찬가지로 Complex& 를 리턴하여 함수 내부에는 미리 만들어 놓은 사칙연산 연산자를 이용하면 된다.

연산자 오버로딩을 사용하게 되면 a += b와 a = a+ b가 반드시 같지는 않을 수 있다. 컴파일러는 사칙연산 연산자가 정의되었다고 해서 자동으로 += 연산자도 계산해주지 않는다.
즉, 연산자 오버로딩을 하게 된다면 모든 연산자들에 대한 개별적인 정의가 필요하다.

-문자열로 Complex 수와 덧셈하기
문자열로도 덧셈을 할 수 있는 operator+ 함수를 만들어보자.
먼저 문자열을 복소수로 표현하기 위해서 다음과 같은 약속이 필요하다.
Complex 클래스의 경우 다음과 같은 꼴로 표현한다.
(부호) (실수부) (부호) i (허수부)
예를 들어서 "2+i3" 이라는 문자열은 다음과 같이 표현된다. (2,3)
또한 "2-i3"은 다음과 같다. (2,-3)
만약 실수부나 허수부의 값이 0이면 굳이 써주지 않아도 된다. 또한 우리가 만든 클래스의 실수부와 허수부는 double 자료형이기 때문에 입력받을 때, 단순히 정수 부분만 받는 것이 아니라 소수점 아래도 처리해주어야 한다.
get_number 함수는 문자열을 인수로 받고 시작 인덱스와 끝 인덱스를 인자로 받는다. 그리고 문자열에서 시작 인덱스부터 끝 인덱스까지 수를 구해서 반환한다.

먼저 문자열을 덧셈의 피연산자로 사용하므로 전달받는 인자는 Complex& 가 아니라 const char* 가 된다. 그 다음 가장 먼저 i의 위치를 구한다. i를 기준으로 실수와 허수가 나뉜다.
만약 i가 존재하지 않는다면 그 수는 실수이므로 간단하게 바꿔준다.
만약 i가 존재하면 i를 기준으로 앞의 숫자를 구해서 실수부분으로 저장하고, 뒤의 숫자를 허수부분으로 저장한다.
만약 허수부분이 존재하는데 i를 기준으로 뒤의 부분만 보게되면 허수부분의 부호를 판단하기가 어려우므로 if(pos_i >= 1 && str[pos_i - 1] == '-') str_img *= -1.0 으로 허수부분의 부호를 판단하였다.