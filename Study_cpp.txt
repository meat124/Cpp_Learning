10-3강 C++ STL 알고리즘

- 람다함수
- 정렬 알고리즘
- 원소 삭제 알고리즘
- 원소 탐색 알고리즘


알고리즘에 정의되어 있는 여러가지 함수들은 크게 두 개의 형태를 가진다.
template <typename Iter>
void do_something(Iter begin, Iter, end);

or

template <typename Iter, typename Pred>
void do_something(Iter begin, Iter end, Pred, pred);

전자의 경우, 알고리즘을 수행할 반복자의 시작점과 끝점 바로 뒤를 받는다.
후자의 경우, 반복자는 동일하게 받되, '특정한 조건'을 추가 인자로 받게 된다.
이러한 '특정한 조건'을 서술자(Predicate) 이라고 부른다.
Pred 에는 보통 bool 을 리턴하는 함수 객체(Functor) 를 전달하게 된다.

- 정렬(sort, stable_sort, partial_sort)
sort : 일반적인 정렬함수 > O(n log n) 의 시간 복잡도 > 퀵, 힙, 머지 소트 등이 존재
stable_sort : 정렬을 하되, 원소들 간의 순서를 보존한다. > 즉 크기가 같다면 기존의 순서를 보존한다는 말 > sort 보다 좀 더 느리다.
partial_sort : 배열의 일부분만 정렬한다.

sort 함수는 정렬할 배열의 시작 위치와 마지막 위치 '바로 뒤' 를 iterator 로 받는다.
sort 에 들어가는 iterator 의 경우, RandomAccessIterator 타입을 만족해야 하므로, vector 와 deque 만 가능하고 나머지 list 와 같은 것들은 불가능하다.
만약 
list<int> l;
sort(l.begin(), l.end());
라는 코드를 작성하면 컴파일 오류가 발생한다.

sort 함수는 기본적으로 오름차순으로 정렬을 해준다.
그렇다면 내림차순으로 하고싶다면 어떻게 할까?
> 3번째 인자로 특정한 조건을 전달하면 된다.

struct int_compare
{
	bool operator()(const int& a, const int& b) const
		{ return a > b; }
};
를 작성해주고 3번째 인자로 전달하면 내림차순 정렬이 가능하다.
함수 객체를 위한 구조체를 정의하고 그 안에 operator() 함수를 만들어주면 함수 객체가 만들어지는 것이다.
그런데 int 나 string 과 같은 기본 타입들은 모두 <, > 연산자들이 기본으로 내장되어 있다. 그래서 굳이 귀찮게 함수 객체를 만들 필요 없이
template <typename T>
struct greater_comp
{
	bool operator()(const T& a, const T& b) const 
		{ return a > b; }
};
로 만들어 주면 타입별로 따로 만들지 않아도 된다.
functional 헤더에 다음과 같은 템플릿 클래스가 존재한다.
std::sort(vec.begin(), vec.end(), greater<int>());
3 번째 인자를 보면 클래스로 제공하는 greater 함수가 있다.

partial_sort() 함수는 인자를 start, middle, end 이렇게 3 가지를 받는다.
정렬을 [start, end) 전체 원소들 중에서 [start, middle) 까지의 원소들이 전체 원소들 중에서 제일 작은애들 순으로 정렬시킨다
즉 나머지 원소들은 랜덤하게 남아있게 된다.
따라서 전체 원소의 개수가 N 개이고 정렬하려는 부분의 크기가 M 이라면 partial_sort 의 복잡도는 O(N log M) 가 된다.

즉 우리가 전체 배열을 정렬할 필요 없이 100명 중 상위 10명의 성적을 성적순으로 보고싶다면 굳이 sort 를 할 필요 없이, partial_sort 를 사용하는 것이 훨씬 빠르다.

sort 함수는 최악의 경우에서 O(n log n) 이 보장되지만, stable_sort 의 경우 최악의 경우에서 O(n (log n)^2) 으로 작동하게 된다.

- 원소 제거(remove, remove_if)

대부분의 컨테이너는 원소를 제거하는 함수를 지원한다.
vec.erase(vec.begin() + 3) 과 같이 하면 vec[3] 에 해당하는 원소를 제거하게 된다.

그런데 함수 하나로는 많은 작업들을 처리하기에는 부족하다.
예를 들어서 값이 3인 원소를 제거하려면 어떻게 해야 하는가?
만약 원소를 erase 함수로 제거하면 그에 따른 iterator 가 초기화 되므로 다시 반복자를 vec.begin() 으로 초기화 하고 다시 반복해야 한다.
이는 바람직한 방법이 아니다.

Iterator erase(Iterator pos); >> pos 가 가리키는 원소를 벡터에서 지우는 형태
Iterator erase(Iterator first, Iterator last); >> first 부터 last 사이에 있는 모든 원소들을 지움

remove 함수는 원소의 이동만을 수행하고 실제로 원소를 삭제하는 연산을 수행하지는 않는다.
따라서 벡터에서 실제로 원소를 지우기 위해서는 반드시 erase 함수를 호출하여 실제로 원소를 지워줘야 한다.
remove 함수의 반복자는 타입이 ForwardIterator 이다. 즉 벡터 뿐만 아니라, 리스트, 혹은 셋이나 맵에서도 모두 사용 가능하다.

만약 '특정한 조건' 을 만족하는 원소들을 제거하려면 어떻게 할까?
그 조건을 만족하는지 아닌지를 판단하는 함수들을 전달해야 한다.
이를 위해서 remove_if 함수를 제공한다.

즉 remove 함수는 3번째 인자로 제거할 값을 전달받을 수 있고, remove_if 함수는 3번째 인자로 특정한 조건에서 true or false 를 리턴할 함수 객체를 전달받는다.(struct 선언하고 안에 bool 을 리턴하는 함수정의)
이때, 함수 객체로 실제 함수를 전달할 수도 있다.
이 경우 
template <typename Iter, typename Pred>
remove_if(Iter first, Iter last, Pred pred)
에서 Pred 가 함수 포인터 타입이 될 것이다.

원칙 상 remove_if 에 3번째 인자로 전달되는 함수 객체의 내부 상태는 이전의 호출에 의해 내부 상태가 달라지면 안된다.
이는 C++ 표준에 따른 것이다.
따라서 함수 객체 안에 인스턴스 변수를 넣고 값을 변경하는 것은 원칙 상 불가능하다.
그 이유는 remove_if 를 실제로 구현했을 때, 해당 함수 객체가 여러번 복사될 수 있기 때문이다.
그렇다면 인스턴스 변수를 객체 내부가 아닌 외부 변수로 빼보자.
그렇다면 성공적으로 실행된다.
즉 객체 내부에는 인스턴스 변수를 포인터로 선언한다.
int* num_delete;
그리고 호출 시에 인자로 &num_delete 를 전달하면 된다.

- 람다 함수(lambda function)
람다 함수는 C++ 11 에서 처음 도입
이름이 없는 함수 객체를 만들기 가능

[capture list] (받는 인자) -> 리턴 타입 { 함수 본체 }

또한 리턴 타입을 생략할 수도 있다. 그러면 [capture list] (받는 인자) { 함수 본체 } 형식으로 작성 가능하다.

[](int i) { return i % 2 == 1; }
으로 작성하면 컴파일러가 알아서 bool 타입을 리턴하는 함수로 인식한다.

실제로 람다함수로 작성하면 이름이 없다. 따라서 함수에 이름이 붙어있지 않다. 즉, 임시적으로 함수를 생성한 것이다.
따라서 이 함수를 사용하고 싶다면 바로 호출하거나
auto func = 람다 함수
이렇게 함수 객체를 생성하고 호출할 수도 있다.
람다 함수도 함수이기 때문에 자기 자신만의 스코프를 가진다.
따라서 일반적인 상황이면 함수 외부에서 정의된 변수들을 사용할 수 없다.
하지만 capture list 로 변수의 레퍼런스를 인자로 전달하면 사용이 가능하다.
capture list 로 전달되면, 마치 함수의 스코프 안에 있는 것 처럼 사용이 가능하다.
전달하는 인자에 & 를 붙이는 것은 레퍼런스를 전달한다는 의미이다. 즉 값을 바꿀 수 있게 된다.
만약 & 를 붙이지 않는다면 전달된 인자의 복사본을 얻게 되고, 그 형태는 const 이므로 값을 바꿀 수 없다.
즉 call-by-value 이므로 값의 변경이 불가하다.
call-by-reference 이어야 값의 변경이 가능하다.

여기서 만약 클래스의 멤버 함수 안에서 람다 함수를 사용할 때, 멤버 변수들을 참조하려면 어떻게 해야할까?
일반 변수가 아니라 객체에 종속된 멤버 변수이므로, 람다 함수는 객체의 멤버 변수가 아니라 일반 변수라고 생각하게 된다.
따라서 직접 멤버 변수를 사용하는 것 보다는 this 를 전달해 주는것이 좋다.
1. [] : 아무것도 캡쳐 안함
2. [&a, b] : a 는 레퍼런스로 캡쳐하고, b 는 복사본으로 캡쳐
3. [&] : 외부의 모든 변수들을 레퍼런스로 캡쳐
4. [=] : 외부의 모든 변수들을 복사본으로 캡쳐

- 원소 수정하기(transform)

많은 경우, 컨테이너 전체, 혹은 일부를 순회하면서 값들을 수정하는 작업을 많이 할 것이다. 예를 들어서 벡터의 모든 원소에 1을 더한다 같은 작업이다. 
이러한 작업을 도와주는 함수는 바로 transform 함수이다.
형태는 다음과 같다.
std::transform( 시작 반복자, 끝 반복자, 결과를 저장할 컨테이너의 시작 반복자, Pred );
따라서 여기서 결과를 저장할 컨테이너는 무조건 기존의 컨테이너보다 최소한 같거나 커야한다.
만약 그러지 않다면, 런타임 오류가 발생하게 된다.

이렇게 transform 함수를 이용하면 컨테이너의 값을 참조할 때, 귀찮게 for 문을 사용할 필요 없이 바로 사용 가능하다.
또한 내가 이 코드에서 무슨 작업을 하는지 더 간단명료하게 나타낼 수도 있다.

- 원소를 탐색하는 함수(find, find_if, any_of_, all_of)

std::find(시작 반복자, 끝 반복자, 찾고자 하는 값);
반복자에 따라서 forward_iterator 이면 앞에서 부터 찾고, reverse_iterator 이면 뒤에서 부터 거꾸로 찾게 된다.
컨테이너에 중복되는 값이 있어도 가장 먼저 찾은 것을 리턴한다.

find 계열의 함수들을 사용할 때, 한 가지 주의할 점
만약 컨테이너에서 기본적으로 find 함수를 지원한다면 이를 사용하는 것이 훨씬 빠르다.
왜냐하면 알고리즘 라이브러리에서의 find 함수는 그 컨테이너가 어떠한 구조를 가지고 있는지에 대한 정보가 하나도 없기 때문
따라서 set 의 경우 set 에 내장된 find 함수는 O(log n) 의 시간복잡도로 수행될 수 있는데 그 이유는 set 이 내부적으로 원소들이 정렬되어 있기 때문이다.
또한 unordered_set 의 경우 O(1) 로 수행이 이뤄진다. 이는 자체적으로 해시 테이블을 이용하기 때문이다.
하지만 그냥 find 함수를 사용하면 O(n) 으로 수행되므로 추가 정보가 있는 것을 모른 채, 탐색을 하게 된다.
따라서 find 함수를 지원하지 않는 컨테이너에 한해서만 알고리즘의 find 함수를 사용하기 바란다.

any_of 함수는 인자로 받은 모든 범위 안의 모든 원소들 중에서 조건을 만족하는 원소가 하나라도 있으면 true 를 리턴한다.
all_of 함수는 인자로 받은 모든 범위 안의 모든 원소들이 조건을 만족해야 true 를 리턴한다.
즉 any_of 함수는 OR 연산과 비슷하고, all_of 연산은 AND 연산과 비슷하다고 볼 수 있다.