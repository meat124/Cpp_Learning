9-1강 C++ 템플릿

벡터 : 가변 길이 배열

데이터 타입이 바뀔 때 마다 다른 벡터를 만들어주어야 한다.
일반적으로 벡터는 string 타입의 문자열을 인자로 받지만, 우리가 만약에 int 또는 char 과 같은 자료형을 인자로 받고싶은 경우
코드에서 string 부분은 바꿔주어야 한다.
하지만 이는 큰 낭비이다.
만약 T 라는 타입의 객체들을 보관하는 Vector 를 만들고 싶은 경우,
이 경우 C++ 에 존재하는 템플릿의 기능이 필요하다.
즉 우리가 만약 int 를 담는 Vector 가 필요하다면 T 를 int 로 바꾸면 되고, string 을 담는 Vector 가 필요하다면, T 를 string 으로 바꾸면 된다. 이렇게 컴파일러가 알아서 T 부분에 우리가 원하는 타입으로 채워서 코드를 생성하면 편할 것이다.
즉 마치 어떠한 틀에 타입을 접어넣으면 원하는 코드가 나올 수 있게 만드는 것이다.

-C++ 템플릿(template)

>어떠한 물건을 찍어내는 틀

C++ 에서도 위와 같은 의미로 사용된다.
즉 프로그래머가 원하는 타입을 넣어주면 딱 알아서 코드를 찍어내 주는 것이다.

template <typename T> 
템플릿 선언 방식이다.
아래에 정의되는 클래스에 대해 템플릿을 정의하고, 템플릿 인자로 T 를 받게 되며, T 는 반드시 어떠한 타입의 이름임을 명시하고 있다.
만약 밑에 오는 것이 클래스가 아니라 함수이면 함수에 대한 템플릿이 된다.
template <class T> 라는 선언도 존재한다. 이는 위와 동일한 것이다.

이를 메인 함수에서 선언하려면
Vector<int> int_vec; 
클래스이름 <원하는 타입> 인스턴스이름
순으로 코드를 작성하면 된다.
여태까지는 인자로 특정한 값 혹은 객체를 전달했지만, 타입 그 자체를 전달한 적은 없었다. 하지만 이제 템플릿을 사용하면서 이게 가능해진다.

클래스 템플릿에 인자를 전달해서 실제 코드를 생성하는 것을 클래스 템플릿 인스턴스화 라고 한다.
템플릿이 인스턴스화 되지 않고 있다면 컴파일 시에 아무런 코드로 변환되지 않는다.
이때 간혹 일부 타입에 대해서는 다른 방식으로 처리해야 할 필요가 있다.
만약 bool 타입의 데이터를 보관하는 벡터에 대해 생각해보자
Vector<bool> int_vec;
이러한 경우에 특수하게 처리를 해주어야 한다.

-템플릿 특수화(template specialization)
template <typename A, typename B, typename C> 일 때, 만약 원하는 인자에 따라서 다르게 처리하고 싶다면
class test<int , B, double> 처럼 원하는 인자만 골라서 처리해주면 된다.


*** bool 타입이 1비트가 아니라 8비트, 즉 1바이트로 표현되는 이유 : single bit 에 포인터를 생성하려면 addressable 해야 한다. 하지만 1비트라면 포인터 생성이 불가하다. 따라서 bool 타입의 변수는 1바이트로 표현되어야 한다. 
이는 모든 타입의 변수에 동일하게 적용된다. 따라서 C++ 의 모든 데이터 타입은 절대로 1바이트 보다 작을 수 없다!
boolean 의 저장 방식
if true
0000 0001
if false
0000 0000
용량이 1 바이트인 자료형은 원래 2^8 가지의 수를 표현이 가능하다.
하지만 boolean 은 1비트만 표현가능, 즉 2가지의 수만 표현이 가능하다(참, 거짓)
따라서 참, 거짓만을 표현할 때는 int형(4바이트) 보다는 메모리 절약이 가능하지만 그 이외에는 매우 효율이 떨어진다.

^ 연산자 : 서로 다르다면 1을, 같다면 0을 반환
<< , >> 연산자 : 비트를 이동하는 시프트 연산, <<는 왼쪽으로, >> 는 오른쪽으로 이동한다. 이를 좀 더 자세히 보면, << 연사는은 2의 거듭제곱을 곱하는 것이고, >> 는 2의 거듭제곱으로 나누는 것이다.

unsigned int 에서 i / 32 는 10진수 형태로 구하는 것이고, i % 32 는 2진수 형태로 구하는 것이다.