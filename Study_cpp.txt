7-1강 C++ 에서의 입출력(istream, ostream)

io_base 와 ios 클래스는 입출력 작업을 위해 바탕을 깔아주는 클래스이다.
istream은 실제로 입력을 수행하는 클래스이다.

-istream 클래스

대표적으로 우리가 항상 사용하던 operator>> 가 istream 클래스에 정의되어 있는 연산자이다.
cin은 istream 클래스의 객체 중 하나이다.

우리가 어떤 타입에 대해서도 cin을 사용할 수 있었더 이유는 operator>> 가 그런 모든 기본 타입들에 대해서 정의가 되어있고 따라서 오버로딩이 수행되어서 자동으로 맞는 타입을 찾아가기 때문이다.
정의가 되어있지 않은 타입이라도 string 클래스로 선언된 문자열의 경우도 cin으로 입력을 받을 수 있다.
이는 외부 함수로도 연산자 오버로딩이 가능하기 때문이다.
이 경우는
istream& operator>>(istream& in, std::string& s)
{
...
}
으로 나타날 것이다.

operator>> 의 또 다른 특징으로는,  모든 공백문자(띄어쓰기나 엔터, 탭 등등) 을 입력시에 무시해버린다는 점이다. 그렇기 때문에 만일 cin을 통해서 문장을 입력받는다면, 첫 단어만 입력받고 나머지를 읽을 수 없다.

ios 클래스에서 스트림의 상태를 관리한다. 스트림의 상태를 관리하는 플래그가 4개가 정의되어있다.
goodbit : 스트림에 입출력 작업이 가능할 때
badbit : 스트림에 복구 불가능한 오류 발생 시
failbit : 스트림에 복구 가능한 오류 발생 시
eofbit : 입력 작업시에 EOF 도달 시

만약 타입에 맞지 않는 값이 넣어져서 오류가 발생하면 failbit 가 켜지고 입력값을 받지 않고 리턴해버린다.

operator void*() const; 함수는 ios 객체를 void* 로 변환해준다. 이때 NULL 포인터가 아닌 값을 리턴하는 조건은 failbit 와 badbit 가 모두 off일 때 이다. 즉 스트림에 정상적으로 입출력 작업을 수행 할 수 있을 때이다.

fail 함수는 ios에 정의되어있다. failbit 나 badbit 가 true 이면 true를 리턴한다.
ignore 함수는 첫번째 인자 만큼, 두 번째 인자가 나올 때 까지 버퍼에서 무시하는 함수이다.

16진수로 값을 입력받는 또 다른 방법이 있다.
std::cin >> std::hex >> t;
이렇게 하면 hex 가 cin 에서 수를 받는 방식을 바꾸기 때문에 16진수로 받을 수 있다.
이 때문에 hex와 같은, 스트림을 조작하여 입력 혹은 출력 방식을 바꿔주는 함수를 조작자라고 부른다.(hex는 함수이다.) 참고로 ios_base::hex 와 std::hex는 아예 다른 것이다.
형식 플래그 ios_base::hex는 ios_base에 선언되어 있는 단순한 상수 값이지만, 조작자 hex의 경우 ios 에 정의되어 있는 함수이다. 이 조작자 hex의 정의를 살펴보면 ios_base 객체를 레퍼런스로 받고, 다시 그 객체를 리턴한다.
std::ios_base& hex(std::ios_base& str);
그렇다면 operator>> 중에서 위 함수를 인자로 가지는 경우도 있을까?
존재한다.
istream& operator>>(ios_base& (*pf)(ios_base));
이렇게 operator>> 에서 조작자를 받는다면 많은 일을 하는 것이 아니라 단순히 pf(*this) 를 호출하게 된다.
따라서 setf를 사용하지 않더라도 간단하게 조작자를 사용하여 쉽게 입력 형식을 바꿀 수 있다.
조작자들의 종류는 hex말고도 매우 많다. true나 falseㅇ를 1과 0으로 처리하는 대신, 문자열 그대로 입력받는 boolalpha도 있고, 출력 형식으로 왼쪽 또는 오른쪽으로 정렬시키는 left와 right 조작자 등 여러가지가 존재한다.
그 외에도 우리가 계속 사용했던 std::endl도 있다. endl은 hex와 달리 출력을 관장하는 ostream 클래스에 정의되어있는 조작자로, 한 줄 개행문자를 출력하는 것 말고도, 버퍼를 모두 내보내는 flush 역활도 수행한다.
버퍼에 데이터가 얼마나 쌓이든지 상관없잉 바로 출력을 해주는 함수인 flush 함수이다.

모든 입출력 객체들은 이에 대응되는 스트림 객체를 가지고 있게 된다. 따라서 C++ 의 입출력 라이브러리에 대응되는 스트림 버퍼 클래스도 존재한다. 바로 streambuf 클래스이다. 
스트림이란 문자들의 순차적인 나열이다. 우리가 화면에 입력하는 문자도 스트림을 통해서 프로그램에 전달되는 것이고, 하드 디스크에서 파일을 읽는 것도, 다른 컴퓨터와 통신하는 것도 결국 문자들을 주고받는 것 이므로 모두 스트림을 통해서 이뤄진다.
streambuf 클래스는 스트림에 대한 가장 기본적인 제어를 담당한다.
streambuf 클래스는 스트림의 상태를 나타내기 위해 세 개의 포인터를 정의한다. 
1. 버퍼 시작부분을 가리키는 시작 포인터
2. 다음으로 읽을 문자를 가리키는 포인터(스트림 위치 지정자)
3. 버퍼의 끝 부분을 가리키는 끝 포인터
클래스는 입력 버퍼와 출력 버퍼를 구분해서 get area 와 put area 라 부른다. 이에서 가리키는 포인터도 각각 g, p 를 붙여서 표현한다.
cin.rdbuf 함수를 통해서 streambuf 객체를 가리키는 포인터를 리턴한다.
이때 cin 은 istream 의 객체이므로 오직 입력만을 수행하고, 따라서 이때 streambuf 객체에는 오직 get area 만 존재한다.
snextc 함수는 스트림 위치 지정자를 한 칸 전진 시키고, 그 자리에 해당하는 문자를 엿본다.(읽는 것이 아님)
엿본다는 것은 보통 streambuf 객체에서 읽게 되면, 스트림 위치 지정자를 한 칸 전진시켜서 다음 읽기 때에 다음 문자를 읽을 수 있도록 준비해준다. 하지만 읽지 않고 엿본다는 것은 해당 문자를 읽고도 스트림 위치 지정자를 다음 문자로 움직이 않게 해준다는 것이다. 따라서 다음 읽기 때에 엿본 문자를 읽을 수 있게 된다.

그렇다면 peek 의 결과가 왜 w 가 나오는 지 알아보자.
hello world 에서 cin >> s 이후 스트림 위치 지정자는 hello 와 world 사이의 공백에 위치한다.
hello world\n
문자열의 경우 공백문자가 나오기 전 까지 읽어들이기 때문이다.
여기서 snextc 함수를 호출하면 다음 문자인 w 를 읽기만 하고 스트림 위치 지정자는 다음 문자인 w로 움직인다.
그리고 엿보기를 실행한다. 즉 w를 읽지만 다음 문자로 넘어갈 준비를 하지는 않는다. 따라서 스트림 위치 지정자는 w에 그대로 머물러 있는다.
따라서 s 를 다시 cin >> s; 를 통해 입력 받고, std::cout << s << std::endl 를 통해 실행시키면
world 전체가 그대로 다시 나오게 되는 것이다. 만약 스트림 위치 지정자가 다음 문자로 움직였다면 w는 출력되지 않고 orld 만 출력되었을 것이다.
streambuf 클래스에는 snextc 함수 말고도 수 많은 함수들이 정의되어 있다. 물론 이 함수들을 우리가 직접 사용할 일은 거의 없겠지만, C++ 입출력 라이브러리는 스트림 버퍼도 추상화해서 클래스로 만들었다는 것 정도로 기억하면 좋다.
또한, C++ 에서 streambuf 를 도입한 중요한 이유는 1바이트 문자 뿐 만이 아니라 wchar_t 같은 다중 바이트 문자들(흔히 말하는 UTF-8) 에 대한 처리도 용이하게 하기 위해서이다.
예를 들어서, 다중 바이트 문자의 경우, 사용자가 문자 한개만 요구했음에도 스트림에서는 1바이트만 읽고, 2바이트, 심지어 4 바이트까지 필요한 경우가 존재한다. C++ 에서는 이러한 것들의 처리를 스트림 버퍼 객체 자체에서 수행하도록 해서, 사용자가 입출력 처리를 이용하는데 용이하게 하였다.
