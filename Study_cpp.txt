6-3 강

virtual 키워드를 통해 동적 바인딩(dynamic binding)이라는 것을 할 수 있었다.
Parent 클래스와 Child 클래스에 모두 f라는 가상함수가 정의되어 있고, Child 클래스가 Parent 클래스를 상속 받는다고 한다. 이때 동일한 Parent* 타입의 포인터들도 각각 Parent 객체와 Child 객체를 가리킨다고 해보자. 
Parent* p = new Parent();
Parent* c = new Child();
이때 컴퓨터는 p,c 모두 Parent를 가리키는 포인터 이므로 당연히
p->f();
c->f();
를 하면 모두 Parent의 멤버 함수인 f 가 실행되어야 한다.
하지만 f 함수는 가상함수 이므로 실제로 c가 가리키는 객체인 Child 객체의 함수 f를 호출하게 된다.

-virtual 소멸자
상속 시에, 소멸자를 가상함수로 만들어야 한다.
Parent* p = new Child();
로 선언하면 delete p; 를 하더라도
p가 가리키는 것은 Parent 객체가 아닌 Child 객체이기 때문에 Child 객체가 호출되지 않는다.
이렇게 소멸자가 호출되지 않으면 메모리 누수가 발생할 수 있다.
Parent의 소멸자를 virtual 키워드를 붙여서 선언하면 된다.
그렇다면 Child 의 소멸자를 성공적으로 호출할 수 있게 된다.
그렇다면 여기서 왜 Parent 의 소멸자도 호출이 되었을까?
이는 Child의 소멸자를 호출하면서 Child 소멸자가 알아서 Parent 의 소멸자도 호출해주기 때문이다.
즉 Child 는 자신이 Parent 의 상속을 받는다는 것을 알고있기 때문에 자동으로 Parent 의 소멸자도 호출하게 된다.
따라서 상속될 여지가 있는 Base 클래스들은 반드시 소멸자에 virtual 키워드를 붙여서 선언해주어야 나중에 문제가 발생할 여지를 없앨 수 있다.

-가상 함수의 구현 원리
그렇다면 모든 함수를 virtual 키워드를 붙여서 선언하면 안되는건가?
>>실제로 java 에서는 모든 함수들이 디폴트로 virtual 함수로 선언된다.
하지만 보통 함수를 호출하는 것 보다 가상 함수를 호출하는데 걸리는 시간이 좀 더 오래 걸린다.
약간의 오버헤드(overhead)가 존재한다.
먼저 동적 바인딩이 어떻게 구현되는지 살펴본다.
C++ 컴파일러는 가상함수가 하나라도 존재하는 클래스에 대해서, 가상 함수 테이블(virtual function table)을 만들게 된다. 이러한 가상함수 테이블은 전화번호부라고 생각하면 된다.
함수의 이름과 실제로 어떤 함수가 대응하는지를 테이블로 저장하고 있는 것이다
예제의 경우 두 개의 클래스 모두 가상함수를 포함하고 있으므로 두 개 다 가상함수 테이블을 만들게 된다.
그 결과 클래스 내부에 가상함수가 아닌 비 가상함수들은 단순히 특별한 단계를 거치지 않고 func3()를 호출하면 직접 실행된다. 하지만 가상 함수를 호출하게 되면 그 실행과정이 다르다. 가상 함수는 한 단계를 더 거쳐서 실제로 어떤 함수를 고를지 결정하게 된다. 따라서 일반적인 함수보다 약간 더 시간이 오래 걸리게 된다.
이 차이는 극히 미미하지만 최적화가 매우 중요한 분야에서는 이를 감안할 필요가 있다.
따라서 이러한 이유로 인해 C++ 에서는 멤버 함수가 디폴트로 가상함수가 되도록 설정되지 않는다.

-순수 가상 함수(pure virtual function) 와 추상 클래스(abstract class)

가상 함수로 선언하고 = 0 을 붙여서 처리한 함수는 "무엇을 하는지 정의되어 있지 않은 함수" 이다. 즉 반드시 오버라이딩 되어야 하는 함수라고 볼 수 있다.
이런 형태의 함수를 완전한 가상 함수라고 해서 '순수 가상 함수(pure virtual function)' 라고 한다.
이러한 순수 가상 함수는 본체가 없기 때문에, 이 함수를 호출하는 것은 불가능하다. 그렇기 때문에 예제의 Animal 객체를 생성하는 것 또한 불가능하다.
왜냐하면 Animal a; a.speak() 을 하면 안되기 때문이다. 따라서 이러한 호출을 컴파일러에서 금지하면 되지 않냐는 의문이 생기는데 이는 개발자들이 그냥 Animal 의 객체 생성을 금지시키는 것으로 택하였다. 즉 Animal 의 인스턴스를 생성 금지
따라서 Animal의 객체를 생성하려 하면 컴파일오류가 발생한다.
이렇게 순수 가상 함수를 최소 한 개 이상 포함하고 있는 클래스는 객체를 생성할 수 없으며, 인스턴스화 시키기 위해서는 이 클래스를 상속받는 클래스를 만들어서 모든 순수 가상 함수를 오버라이딩 해주어야 한다.
이렇게 반드시 상속만 되어야 하는 클래스를 가리켜서 추상 클래스(abstract class)라고 부른다. 
>> 추상적으로 존재하고 실제로 그 자체로 인스턴스 생성은 불가하지만 상속을 통해 나타나는 형태
이러한 추상화를 이용하여 추상 클래스를 사용하는 이유는 무엇일까?
추상 클래스 자체로는 인스턴스화 할 수 없지만 추상 클래스를 '설계도'라고 생각하면 된다.
이 클래스를 상속받아서 사용하는 사람에게 "이 기능은 일반적인 상황에서 만들기 힘드니 너가 직접 특수화 되는 클래스에 맞추어서 만들어서 써라" 라고 말해주는 것이다. 
즉 동물들이 소리를 내는 것은 맞으므로 Animal 클래스에 speak 함수는 필요하다. 하지만 어떠한 소리를 내는지는 동물마다 다르므로 speak 함수를 가상 함수로 만들기는 불가능하다. 따라서 추상화를 이용하면 Animal 들은 speak 한다는 의미 전달과 함께 각각의 동물 클래스에서 상속을 받아서 어떠한 소리를 내는지는 각각의 클래스 내부에서 정의하면 된다.
여기서 중요한 점은 추상 클래스는 객체 생성은 불가하지만, 추상 클래스를 가리키는 포인터는 문제 없이 만들 수 있다는 점이다. 

-다중 상속(multiple inheritance)
상속의 또 다른 특징인 다중 상속에 대해 알아본다.
C++에서는 한 클래스가 여러 개의 클래스들을 상속받는 것을 허용한다. 이를 가리켜서 다중 상속 이라고 한다.

생성자 호출의 순서는 오로지 상속하는 순서에 따라서만 좌우된다는 것을 확인할 수 있다.

만약 두 개의 클래스에서 이름이 같은 멤버 변수나 함수가 존재한다고 해보자. 그렇다면 중복되는 멤버 변수에 접근하게 되면, 컴파일러는 그 둘 중에 어떤 변수인지 구분 할 수 없다는 오류를 띄운다. 
다이아몬드 상속 이라 부르는 다중 상속이 있다.
상속이 되는 두 개의 클래스가 공통의 베이스 클래스를 포함하고 있는 형태를 다이아몬드 상속이라 부른다.
이러한 형태의 상속의 문제점은 다음과 같다.
> 1차적으로 상속받는 클래스들은 각각 베이스 클래스의 변수들을 상속받게 된다. 그런데 최종 클래스는 두 개의 클래스를 상속받으니 이 이름이 같은 변수들이 겹치게 되는 것이다. 즉 베이스 클래스의 변수나 함수들이 공통적으로 겹치게 되면서 오류가 발생한다.
이러한 문제를 해결하려면 1차적으로 상속받는 클래스들이 베이스 클래스를 상속받을 때 virtual 로 상속을 받으면 된다. 이러면 컴파일러가 언제나 베이스 클래스를 한 번만 포함하도록 지정할 수 있게 된다.

-다중 상속은 언제 사용해야 할까?
클래스를 디자인 하는 방법 중 3가지가 있다.
브리지 패턴(bridge pattern), 중첩된 일반화 방식(nested generalization), 다중 상속 이다. 각각의 방식에는 모두 장단점이 존재한다.
차량에 대한 클래스를 디자인 할 때, 차량이 작동하는 환경이 N 가지 존재하고, 동력원의 종류가 M 가지 존재한다고 하자.
브리지 패턴 : 한 가지 카테고리를 아예 멤버 포인터로 만들어 버린다. 총 N + M 개의 클래스만 생성하면 된다.
이러한 경우 오버라이딩 가지수가 N + M 개 뿐이므로 최대 N + M 개의 알고리즘 밖에 사용할 수 없다. 따라서 섬세한 제어가 필요하다면 이러한 브리지 패턴은 사용하지 않는 것이 좋다. 또한 컴파일 타임 타입 체크를 적절히 활용할 수 없다는 문제가 있다. 또한 예를 들어 우주에서 작동하는 모든 차량을 가리킬 수 있는 기반 클래스를 만들 수 있지만, 작동 환경에 관계 없이 휘발유를 사용하는 모든 차량을 가리킬 수 있는 기반 클래스를 만들 수는 없다.
중첩된 일반화 : 한 가지 계층을 먼저 골라서 파생 클래스들을 생성한다. 최대 N * M 개의 파생 클래스들을 생성할 수 있게 된다. 따라서 브릿지 패턴에 비해서 좀 더 섬세한 제어를 할 수 있게 된다. 하지만 동력원을 하나 추가한다면 최대 N 개의 파생 클래스를 더 만들어야 한다. 
다중 상속 : 다중 상속을 이용하면 각 카테고리에 해당하는 파생 클래스들을 만들게 되지만 그 대신 멤버 포인터를 없애고 동력원과 환경에 대항하는 클래스를 상속받는 파생 클래스들을 최대 N * M 개 만들게 된다. 예를 들어서 휘발유를 사용하며 지상에서 다니는 차량을 나타내는 GasPoweredLandVehicle 클래스의 경우, GasPoweredEngine 과 LandVehicle 두 개의 클래스를 상속받을 것이다.

위의 3 가지 방식 중에서 절대적으로 우월한 방식은 없다. 따라서 개발자가 상황에 맞게 최선의 방식을 골라서 사용해야 한다. 다중 상속은 절대로 만능 툴이 아니며 다중 상속을 이용해서 해결해야 할 것 같은 문제도 알고 보면 단일 상속을 통해서 해결할 수 있는 경우들이 있다. 따라서 적절한 상황에서 다중 상속을 이용하는 것이 필요하다.