7-2강 파일 입출력 std::ifstream, std::ofstream, std::stringstream

파일 입력, 파일 출력, 간편한 문자열 간의 변환에 대해 알아본다.

표준 입출력에서 파일 입출력으로 바뀐 것은 스트림이 화면 혹은 키보드에서 파일로 바뀌었다는 것 말고는 다른 것이 없다.

-fstream
파일 스트림은 기본적인 istream 이나 ostream 클래스보다 지원하는 기능이 더 많다.
따라서 이 각각을 상속받아서 이용하는데 이것이 ifstream 과 ofstream 이다.
(input file stream, output file stream)
따라서 이 클래스를 모두 포함하는 라이브러리로 fstream 을 사용하면 ifstream 과 ofstream 을 모두 사용 가능하다.

cout 나 cin 을 사용할 때는 이미 표준 입출력에 연동이 되어있는 상황이었지만, 파일 입출력을 하는 경우에는 어느 파일에 입출력을 해야 할 지 지정해야 한다. 따라서 ifstream 객체에 생성자에 연동하고자 하는 파일의 경로 "C:/a/b/c/test.txt" 를 전달하면 된다. 예제의 코드의 경우는 편의를 위해서 파일 이름만 적었다. 이 경우는 실행파일과 같은 경로에 있는 파일을 자동으로 찾게 된다. 따라서 다른 경로에 있는 파일의 경로를 적으려면 실제 주소를 적어야 한다.
생성자에 파일 경로를 지정하면, 해당하는 파일을 찾고 열게 된다. 만약 파일이 존재하지 않으면 파일을 열 수 없다. 따라서 파일이 열렸는지의 유무는 다음과 같이 확인 가능하다.
if ( in.is_open())
is_open 은 기존의 istream 에는 없고, ifstream 에서 상속받으면서 추가된 함수이다. 파일이 열렸는지의 유무를 리턴한다. 만약 존재하면 true 를 리턴하고, 존재하지 않으면 false 를 리턴한다.
in >> s; 
이러하게 cin 을 이용하는 것 처럼 in 객체를 이용해서 파일을 읽을 수 있다.
C언어에서는 파일 입출력을 한 후에 꼭 fclose 를 해주어야 했다. 하지만 C++ 에서는 그러한 작업을 하지 않는다.
이미 ifstream 객체의 소멸자에서 자동적으로 fclose 를 해주기 때문이다.

하지만 만약 새로운 파일에서 같은 객체가 입력을 받기 위해서는 기존 파일 스트림과의 연결을 종료하고, 새로운 파일과 연결을 시켜주면 된다. 기존 파일과의 스트림 종료는 close 함수가, 새로운 파일과의 연결은 open 함수가 수행한다.
open 함수가 존재하므로 굳이 ifstream 객체 생성자에서 파일 경로를 지정해 줄 필요는 없고, 나중에 open 으로 원하는 파일을 열어도 상관없다.

in.seekg(0, std::ios::end);
fseek 과 같은 함수로, 파일 위치 지정자를 사용자가 원하는 대로 움직일 수 있다.
두 번째 인자는, 파일 내 위치를 의미한다. 첫 번째 인자는 그 위치로부터 얼마나 떨어져 있느냐를 의미한다.
위의 코드는 위치 지정자를 파일의 끝에서 0만큼 떨어진 것, 즉 파일의 끝으로 이동시켰다.

int size = in.tellg();
tellg 함수는 위치 지정자의 위치(시작 지점으로 부터)를 반환한다. 현재 우리가 위치 지정자를 파일의 끝으로 이동시켰으므로, tellg 함수는 파일의 총 크기를 바이트 단위로 반환하게 된다.
그리고 문자열에 그 만큼의 크기를 할당시켜준다. 즉 size 변수에 파일의 사이즈를 초기화 시키는 것이다.

in.seekg(0, std::ios::beg);
이제 파일을 읽는다. 파일 위치 지정자를 현재 파일의 끝으로 옮겨두었으므로 읽기 위해서는 다시 처음으로 돌려놓아야 한다. 옮기지 않는다면 파일 위치 지정자가 파일의 끝에 있으므로 아무것도 읽지 못한다.
따라서 std::ios::beg 를 이용해서 파일의 처음으로 다시 위치 지정자를 옮긴다.

in.read(&s[0], size);
마지막으로 파일 전체에 내용을 문자열에 저장한다.

-한 줄 씩 읽기
ifstream 객체의 멤버 함수로 존재하는 getline 함수는 파일에서 개행문자 \n 이 나올 때 까지 최대 지정한 크기 - 1 만큼 읽는다. 그 이유는 마지막에는 널 문자가 들어가야 하기 때문.

ifstream 에는 자기 자신을 bool 로 캐스팅 할 수 있는 캐스팅 연산자 operator bool() 가 오버로딩 되어있다. 따라서 while 문의 조건에 in 인스턴스를 전달하면 bool 로 캐스팅이 되는 연산자 함수가 호출된다. 이 때 in 이 true 이기 위해서는 다음 입력 작업이 성공적이어야 하고 현재 스트림에 오류 플래그가 켜져 있지 않아야 한다.(총 4 개의 플래그 존재)

하지만 getline 함수는 개행 문자(또는 지정한 문자)가 나오기 전에 지정한 버퍼의 크기가 다 차게 된다면 failbit 를 키게 되므로 버퍼의 크기를 너무 작게 만든다면 정상적으로 데이터를 받을 수 없다. 따라서 getline 을 사용하기 전에 이러한 조건을 꼭 확인해야 한다.
이러한 한계를 극복하기 위해서 std::string 에서 getline 함수를 제공하고 있다.
기존의 ifstream 의 getline 함수를 활용할 때보다 편리한 것은, 굳이 버퍼의 크기를 인자로 지정하지 않아도 되어서 알아서 개행문자 혹은 파일의 끝이 나올 때 까지 입력받게 된다.
*** 주의 사항으로 while문 조건으로 절대 in.eof() 를 사용하면 안된다. 왜냐하면 eof 함수는 파일 위치 지시자가 파일의 끝에 도달한 이후에 true를 리턴하기 때문이다. 
만약 while 문 안에서 파일을 읽다가 파일의 끝(EOF) 바로 직전까지 읽었다고 해본다. 그렇다면 아직 EOF 를 읽지 않았으므로 in.eof() 는 참인 상태이다. 그 상태에서 만약 in >> data 같은 코드를 실행하면 data 에는 아무것도 들어가지 않는다. 즉 초기화가 되지 않은 상태로 남아있게 된다.
즉 in.eof() 는 while 문 안에서 "파일 읽기가 안전하다" 라는 것을 보장하지 않는다.
따라서 정확한 사용법은 while 문의 조건에 in.eof() 가 아니라 in 자체를 넣는 것이다. >> while(in)
스트림 객체 자체를 전달해야만 다음 읽기가 안전할 때만 true로 캐스팅 되어서 전달되고 while문이 실행된다.


-파일에 쓰기
ofstream 을 이용한다. 
out 객체를 생성하고 out << "쓰고 싶은 문구"; 코드를 컴파일 하면 파일에 쓰기가 완료된다.
만약 파일이 존재하지 않는 경우, 파일을 생성한 뒤에, 생성이 성공하였다면 출력하게 된다.
만약 해당 파일이 이미 존재한다면, 특별한 설정을 하지 않는다면, 해당 파일의 내용이 다 지워지고 새로운 내용으로 덮어 씌어지게 된다.
ofstream 클래스의 객체인 out 을 생성할 때 생성자 인자로 app 을 추가로 하면, 파일에 스트림을 연결할 때 기존 파일의 내용을 지우고 쓰는 것이 아니라 그 뒤에 새로운 내용을 붙여서 쓰게 된다.
앞에서 나왔던 ios::binary 와 ios::app 말고도 4개가 더 있다.
1. ios::ate : 자동으로 파일 끝에서부터 읽기와 쓰기를 실시한다. ( 즉 파일을 열 때 위치 지정자가 파일 끝을 가리키고 있게 된다.)
2. ios::trunc : 파일 스트림을 열면 기존에 있던 내용들이 모두 지워진다. 기본적으로 ofstream 객체를 생성할 때 이와 같은 설정으로 만들어진다.(기존 내용 전부 삭제)
3. ios::in, std::ios::out : 파일에 입력을 할 지 , 출력을 할 지 지정하며, ifstream 과 ofstream 객체를 생성할 때, 각각은 이미설정되어 있다.

참고로 ios::ate 와 ios::app 은 비슷해 보이지만 차이가 있다. ios::app 의 경우, 원본 파일의 내용을 무조건 보장하지만, ate는 위치 지정자를 그 이전으로 옮길 수 있다. 즉 app 의 경우 파일 위치 지정자가 기존 파일의 끝이 시작점이라 생각하여 움직인다. ate의 경우 기존 파일을 포함해서 움직인다.( ate를 사용할 일은 거의 없다.)
ios::app 주로 사용!
ate 가 기존 파일을 포함해서 움직인다고 해서 기존에 있는 파일 데이터 한 가운데서 무언가를 끼워 넣을 수 있는 것은 아니다.
app 을 사용해서 문자열을 입력한 경우, 기존의 내용을 보존하고 내용이 추가 되었지만, ate 를 사용한 경우 기존 문자열의 내용이 지워졌다. 즉 ate 는 기존 파일의 내용을 보존하지 않는다.

-std::ofstream 연산자 오버로딩 하기
이전에 했던 것 처럼 ofstream 도 마찬가지로 단순히 ofstream 객체의 레퍼런스를 받고, 다시 이를 리턴하는 operator<< 함수를 정의해주면 된다.

-문자열 스트림(std::stringstream)
#include<sstream> 을 통해서 라이브러리 추가 가능
sstream 에는 std::istringstream 이 정의되어 있다. 이는 마치 문자열을 하나의 스트림이라 생각하게 해주는 가상화 장치라고 보면 된다.
예를 들어서 문자열 "123"이 기록되어 있는 입력 스트림을 생성하였다.
파일에 123 이라 기록해놓고 입력받는 것과 동일하다고 생각하면 된다.
그래서 마치 파일에서 숫자를 읽어내는 것 처럼 std::istringstream 을 통해서 123을 읽어낼 수 있다.
이를 활용하면 atoi 와 같은 함수를 사용할 필요 없이 간편하게 문자열에서 숫자로 변환하는 함수를 만들 수 있다.