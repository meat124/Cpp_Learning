10-1강 C++ STL

-C++ 표준 템플릿 라이브러리(Standard Template Library - STL)

C++ 표준 라이브러리를 보면 대표적으로 iostream, chrono, regex 등이 있다.
하지만 여기서 STL 을 말하면 다음과 같은 3개의 라이브러리를 의미한다.
1. 임의 타입의 객체를 보관할 수 있는 컨테이너(container)
2. 컨테이너에 보관된 원소에 접근할 수 있는 반복자(iterator)
3. 반복자들을 가지고 일련의 작업을 수행하는 알고리즘(algorithm)

여기서 컨테이너는 객체가 어떤 특성을 갖는지 무관하게 라이브러리를 자유롭게 사용할 수 있다.
우리가 사용하려는 자료형이 int 나 string 같은 것 뿐만 아니라 우리가 직접 만든 임의의 클래스의 객체들이어도 그곳에 라이브러리의 기능들을 모두 활용할 수 있다. 이는 C 에서는 불가능한 일이다.

또한 반복자(iterator)의 도입으로 알고리즘 라이브러리에 필요한 최소한의 코드만을 작성할 수 있게 되었다. 즉 M 개의 컨테이너가 있고, N 종류의 알고리즘이 있다면 기존에는 MN 개의 알고리즘 코드가 있어야 했다.
하지만 반복자를 이용해서 컨테이너를 추상화 시켜서 접근할 수 있으므로 N 개의 알고리즘 코드만으로 M 종류의 컨테이너들을 모두 지원할 수 있게 된다.

- C++ STL 컨테이너 벡터(std::vector)
STL 에서 사용하는 컨테이너는 크게 두 가지로 나뉜다.
먼저 배열처럼 객체들을 순차적으로 보관하는 시퀀스 컨테이너(sequence container), 그리고 키를 바탕으로 대응하는 값을 찾아주는 연관 컨테이너(associative container) 가 있다.
먼저 시퀀스 컨테이너에서는 vector, list, deque 가 있다. 
먼저 vector 의 경우, 가변 길이 배열이라 보면 된다.
벡터에는 원소들이 메모리 상에서 실제로 순차적으로 저장되어 있고, 따라서 임의의 위치에 있는 원소를 접근하는 것을 매우 빠르게 수행할 수 있다.

어떠한 작업의 수행 속도를 나타내기 위해서는 수학적으로 나타내야 한다.
컴퓨터 공학에선 어떠한 작업의 처리 속도를 복잡도(complexity) 라고 부르고, 그 복잡도를 Big O 표기법이라는 것으로 나타낸다.
이 표기법은 N 개의 데이터가 주어져 있을 때, 그 작업을 수행하기 위해 몇 번의 작업을 필요로 하는지 N 에 대한 식으로 표현하는 방식이다. 즉 복잡도가 클 수록 작업이 수행되는 데 걸리는 시간이 늘어난다.

가장 기초적인 버블 정렬을 생각해보자. 
for (int i = 0; i < N; i++) {
  for (int j = i + 1; j < N; j++) {
    if (arr[i] > arr[j]) {
      swap(arr, i, j)
    }
  }
}
이 경우 원소가 N 개인 배열을 정렬하는데에는 총 N(N-1)/2 번의 반복이 필요하다. 따라서 이를 Big O 표기법으로 나타내면
O(N(N-1)/2) 로 볼 수 있고 보통 Big O 표기법으로 나타낼 때는 최고차항만 나타내고 여기서 계수도 생략한다. 왜냐하면 N 이 매우 커지게 되면 최고차항 말고는 그닥 의미가 없게 돼버리기 때문이다.
따라서 최종 버블 정렬 알고리즘의 복잡도는 O(N^2) 라고 볼 수 있다.
이 복잡도의 경우, 그닥 좋은편은 아니다.
시간복잡도의 일반적인 효율을 보면
log n = log 1 < N < N log N < N^2 < 2^N < N! 정도로 표현할 수 있다
물론 N 의 값에 따라서 실제 효율은 바뀔 수도 있다.
가장 이상적인 복잡도는 O(1) 이지만 이는 불가능하고, 보통 log N 이 알고리즘이 낼 수 있는 가장 빠른 속도를 의미한다.

벡터의 경우 임의의 위치에 있는 원소에 접근하는 것을 O(1) 로 수행할 수 있다. 그리고 맨 뒤에 새로운 원소를 추가하거나 제거하는 것 역시 O(1) 로 수행한다. vector 의 임의의 원소에 접근하는 것을 배열처럼 [] 연산자를 통해 하거나 또는 at 함수를 사용하면 된다. 또한 맨 뒤에 원소를 추가하거나 제거하기 위해서는 push_back, pop_back 함수를 사용하면 된다.

벡터의 크기를 리턴하는 함수 size의 경우, 리턴하는 값의 타입은 size_type 멤버 타입으로 정의되어 있다.
맨 뒤에 원소를 추가하는 작업은 amortized O(1) 이라고 한다. amortized 는 분할 상환 이라는 의미이다.
보통 vector의 경우 현재 가지고 있는 원소의 개수보다 더 많은 공간을 할당해 놓고 있다. 예를 들어 현재 원소의 개수가 10개라면 이미 20개를 저장할 수 있는 공간을 미리 할당해 놓게 된다. 따라서 맨 뒤에 새로운 원소를 추가하게 된다면 새롭게 공간을 할당할 필요가 없이, 그냥 이미 할당된 공간에 그 원소를 넣기만 하면 된다. 따라서 대부분의 경우 O(1) 으로 vector 맨 뒤에 새로운 원소를 추가하거나 지울 수 있다.
만약 할당된 공간이 가득 찼다면, 새로운 큰 공간을 다시 할당하고 기존의 원소들을 복사해야한다. 따라서 이 경우 N 개의 원소들을 모두 복사해야 하므로 O(n) 으로 수행된다. 하지만 O(n) 으로 수행되는 경우가 매우 드물기 때문에 전체적으로 평균을 내보았을 때 O(1) 으로 수행됨을 알 수 있다. 따라서 amortized O(1) 이라고 부른다.

vector 는 만능은 아니다. 만약 맨 뒤에 원소를 추가하거나 제거하는 것을 빠르지만, 임의의 위치에 원소를 추가하거나 뺄 경우, 그 뒤에 오는 원소들을 모두 한 칸 씩 이동시켜주어야 한다. 이는 n 번의 복사를 필요로 한다.
따라서 맨 뒤가 아닌 위치에 데이터를 추가하거나 제거하는 작업이 많은 일의 경우, vector 를 사용하는 것은 바람직하지 않다.
vector 의 복잡도를 보면 다음과 같다.
1. 임의의 위치 원소 접근([], at) : O(1)
2. 맨 뒤에 원소 추가 및 제거(push_back, pop_back) : amortized O(1) >> 평균적으로 O(1) 이지만 최악의 경우 O(n)
3. 임의의 위치 원소 추가 및 제거(insert, erase) : O(n)
따라서 어떠한 작업을 하느냐에 따라서 속도차가 매우 크기 때문에, C++ 표준 라이브러리를 잘 사용하려면 이 컨테이너를 어떠한 작업을 위해 사용하는지 정확히 인지하고, 적잘한 컨테이너를 골라야 한다. 즉 어떠한 자료구조를 선택하느냐에 따라서 빠른 작업을 느리게 할 수도 있고, 느린 작업을 빠르게 할 수도 있다.

- 반복자(iterator)
반복자는 컨테이너의 원소에 접근할 수 있는 포인터와 같은 객체
벡터의 경우 [] 연산자로 정수형 변수로 마치 배열처럼 임의의 위치에 접근할 수 있지만, 반복자를 사용해서도 마찬가지 작업을 수행할 수 있다. 특히 알고리즘 라이브러리의 경우 대부분이 반복자를 인자로 받아서 알고리즘을 수행한다.

반복자는 컨테이너에 iterator 멤버 타입으로 정의되어 있다. vector의 경우 반복자를 얻기 위해서는 begin() 함수와 end() 함수를 사용할 수 있다. begin() 함수는 vector 의 첫 번째 원소를 가리키는 반복자를 리턴한다. 그런데 end() 함수는 마지막 원소 한 칸 뒤를 가리킨다. 그 이유 중 가장 중요한 이유는 이렇게 해야 빈 벡터를 가리킬 수 있다는 점이 있다.
만약 end 함수가 마지막 원소를 가리킨다면 빈 벡터를 표현하기 어렵다. 하지만 마지막 원소 한 칸 뒤를 가리키면 만약 벡터가 비었을 경우, begin() == end() 를 통해 빈 벡터를 표현할 수 있다.

템플릿 매개변수를 이용해서 타입을 선언하는 경우 템플릿의 타입에 따라서 달라지므로 의존 타입임을 인지하고, 무조건 선언할 때 컴파일러에게 이는 타입이라고 알려주어야 한다. 따라서 typename 을 붙여서 선언해야 한다.

컨테이너에 원소를 추가하거나 제거하게 되면 기존에 사용하던 모든 반복자들을 사용할 수 없게 된다. 즉 vec.erase(itr) 을 수행하면 더 이상 itr 는 유효한 반복자가 아니게 된다. 또한 end_itr 도 무효화 된다.

vector 에서 지원하는 반복자로 const_iterator 가 있다. 이는 const 포인터 처럼 가리키고 있는 원소의 값을 바꿀 수 없다.
이때 const_iterator 의 경우 cbegin() 과 cend() 함수를 이용하여 얻을 수 있다. 많은 경우, 반복자의 값을 바꾸지 않고 참조만 하므로 const iterator 를 적절히 활용하는 것이 좋다.

마지막으로 역반복자(reverse iterator) 가 있다. 이는 반복자와 똑같지만 벡터 뒤에서부터 앞으로 거꾸로 간다는 특징이 있다.
reverse_iterator 를 초기화 하는 함수인 rbegin() 과 rend() 는 각각 맨 뒤의 원소와 맨 앞의 원소의 한 칸 앞을 가리킨다.
또한 반복자의 값이 증가하면 뒤쪽 원소로 이동하는 것 처럼 역반복자의 경우 값이 증가하면 앞쪽 원소로 가게 된다.

역반복자 역시 상수 역반복자가 있다. const_reverse_iterator 타입이고 crbegin() , crend() 로 얻을 수 있다.

** 정리 ** 
1. std::vector<type>::iterator itr >> begin(), end() >> 반복자
2. std::vector<type>::const_iterator c_itr >> cbegin(), cend() >> 상수 반복자
3. std::vector<type>::reverse_iterator r_itr >> rbegin(), rend() >> 역 반복자
4. std::vector<type>::const_reverse_iterator cr_itr >> crbegin(), crend() >> 상수 역 반복자

역 출력을 했을 때, 반복문의 초기화 값을 std::vector<int>::size_type i = vec.size() - 1 로 타입을 설정하면 이 경우 i =0 이 되고 거기서 i-- 를 하게 되면 -1이 되는 것이 아니라 해당 타입에서 가장 큰 정수가 되어버리고 이는 벡터 인덱스 밖의 값을 참조하므로 오류가 발생하게 된다.
따라서  for문이 영원히 종료되지 않게 되고 런타임 오류가 발생한다.
vector 의 index 를 담당하는 타입이 부호없는 정수이기 때문이다.
이 경우 부호있는 정수로 타입을 선언해야 하는데 타입 캐스팅을 해야 한다는 문제가 발생하게 된다.
따라서 역으로 출력하기를 원하는 경우, 역반복자를 사용하는 것이 가장 효율적이다.

- 범위 기반 for 문(range based for loop)

컨테이너의 원소를 for문으로 접근하는 패턴은 매우 많이 등장한다. 
이러한 패턴을 간단하게 나타낼 수 있는 방식을 제공한다.
for (int elem : vec) {
  std::cout << "원소 : " << elem << std::endl;
}
이 경우 elem 에 vec의 원소들이 매 루프마다 복사되어서 들어가게 된다.
elem = vec[i] 와 같다. 
만약 복사가 아니라 레퍼런스를 받고 싶다면, 레퍼런스 타입으로 바꿔버리면 된다.
즉 for(const auto& elem : vec) 로 선언하면 elem 은 vec 의 원소들을 상수 레퍼런스로 접근하게 된다.

- 리스트(list)
리스트는 양방향 연결 구조를 가진 자료형이다.
vector 와 달리 임의의 위치에 있는 원소에 접근을 바로 할 수 없다. list 컨테이너 자체에서는 시작원소와 마지막 원소의 위치만을 기억하므로 임의의 위치에 있는 원소에 접근하기 위해서는 하나씩 링크를 따라가야 한다.

그래서 리스트에는 아예 [] 나 at 함수가 정의되어 있지 않다.

vector 의 경우 맨 뒤를 제외하고는 임의의 위치에 원소를 추가하거나 제거하는 작업이 O(n) 이었지만, 리스트의 경우 O(1) 으로 매우빠르게 수행될 수 있다. 왜냐하면 원하는 위치 앞과 뒤에 있는 링크 값만 바꿔주면 되기 때문이다.

list 의 반복자의 경우 itr++, itr-- 의 연산만 수행 가능하다. 즉 itr + 5 와 같은 연산이 불가능하다는 의미이다. 그 이유는 리스트는 왼쪽 혹은 오른쪽을 가리키고 있는 원소들의 모임으로 이루어져 있기 때문에, 한 번에 한 칸씩 밖에 이동할 수 없다. 즉, 메모리 상에서 원소들이 연속적으로 존재하지 않을 수 있다는 뜻이다. 반면에 벡터의 경우 메모리 상에서 연속적으로 존재하기 때문에 쉽게 임의의 위치를 참조할 수 있다.

리스트에서 정의되는 반복자의 타입을 보면 BidirectionalIterator 타입인 것을 볼 수 있다.즉 양방향으로 이동가능하지만 한 칸 씩만 가능하다. 반면 벡터에서 정의되는 반복자의 타입은 RandomAccessIterator 이다. 참고로 RandomAccessiterator 는 BidirectionalIterator 를 상속받고 있다.

리스트의 반복자는 BidirectionalIterator 이므로 ++ 연산과 -- 연산만 사용 가능하다. 따라서 for문으로 원소를 하나하나 확인해 보는 것이 가능하다. insert 작업과 erase 작업의 경우 vector에 비해서 매우 빠르게 진행된다.
시간복잡도는 O(1)을 가진다. 이는 vector 의 O(N)에 비해 매우 빠르다.
리스트의 경우는 벡터와는 다르게, 원소를 지워도 반복자가 무효화 되지 않는다. 왜냐하면 각 원소들의 주소값이 바뀌지 않기 때문이다! 벡터는 지우면 뒤의 원소들이 당겨지면서 주소가 바뀌지만 리스트의 경우는 원소에서 양 옆의 값만 가리키기 때문에 반복자가 무효화 되지 않고 계속 진행할 수 있다.

- 덱(deque - double ended queue)
마지막 컨테이너는 덱(deque)이라고 불리는 자료형이다. 덱은 벡터와 비슷하게 O(1)으로 임의의 위치의 원소에 접근할 수 있으며, 맨 뒤에 원소를 추가/제거 하는 작업도 O(1)으로 수행할 수 있다. 뿐만 아니라 벡터와는 다르게 맨 앞에 원소를 추가/제거 하는 작업도 O(1)으로 수행 가능하다.
임의의 위치에 원소를 추가/제거 하는 작업은 벡터와 마찬가지로 O(N)으로 수행가능하다. 그리고 그 속도는 벡터보다 더 빠르다.
그렇다고 덱이 벡터보다 모든 면에서 우위에 있는 것은 아니다.
벡터와는 다르게 덱은 원소들이 실제로 메모리 상에서 연속적으로 존재하지는 않는다. 따라서 원소들이 어디에 저장되어 있는지에 대한 정보를 보관하기 위해 추가적인 메모리가 더 필요하다. (64bit 라이브러리의 경우 1개의 원소를 보관하는 덱은 그 원소 크기에 비해 8배나 더 많은 메모리를 필요로 한다.)
>> 즉 덱은 실행속도를 위해 메모리를 많이 희생하는 컨테이너라 보면 된다.
>> 시간 복잡도를 낮추고, 공간 복잡도를 늘린다.
덱은 기본적으로 블록들이 있고 그 블록안에 벡터 형식으로 데이터가 저장된다.
이때 벡터는 메모리를 할당할 때 뒤에만 늘어나는 반면에, 덱에 있는 블록의 벡터형식은 앞뒤로 메모리를 추가 할당한다.
만약 deq.push_back(10); 이라는 코드를 실행하면 새로운 블록을 만들어서 추가되는 원소를 넣어주면 된다.
만약 벡터의 경우 할당된 메모리를 전부 사용한 경우 새롭게 메모리를 할당하고 기존의 벡터에서 원소들을 모두 복사해야 했지만, 덱은 복사할 필요 없이 그냥 새로운 블록을 만들어서 거기에 추가된 원소를 넣어주기만 하면 된다.
따라서 덱은 평균적으로 백터보다 빠르게 작동한다. 물론 덱의 경우, 블록 주소를 보관하는 벡터가 가득 차면 새로운 공간에 모두 복사해야 한다.
하지만 블록 주소의 개수는 전체 원소 개수보다 적고, 대체로 벡터에 저장되는 객체들의 크기가 주소값의 크기보다 크기 때문에 복사속도가 훨씬 빠르게 이뤄지는 것이다.

push_back() : 맨 뒤에 원소 추가
push_front() : 맨 앞에 원소 추가
pop_back() : 맨 뒤에 원소 제거
pop_front() : 맨 앞에 원소 제거

덱 역시 벡터처럼 임의의 위치에 원소에 접근 가능 > [] 연산자와 at 함수를 제공
반복자 역시 RandomAccessIterator 타입이고 벡터와 정확히 동일한 방식으로 작동한다.

- 어떠한 컨테이너를 사용해야 하는가?
1. 일반적인 상황에서는 거의 벡터를 사용한다.
2. 만약 맨 끝이 아닌 중간에 원소들을 추가하거나 제거하는 작업이 많이 이뤄지고, 원소들을 순차적으로만 접근한다면 리스트를 사용
3. 만약 맨 처음과 끝 모두에 원소들을 추가하는 작업을 많이 사용하면 덱을 사용한다.
참고로 O(1)으로 작동한다는 것은 언제나 이론적인 결과이므로 실제로 프로그램을 짜게 되면 O(log n) , O(n) 보다 느릴 수 있다. 즉 n의 크기에 따라서 속도가 중요한 환경이라면 적절한 벤치마크를 통해서 성능을 가늠해 보는 것도 좋다. 