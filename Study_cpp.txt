12-2강 Move 문법 (std::move semantics) 과 완벽한 전달(perfect forwarding)

- move 문법
- 완벽한 전달
- 레퍼런스 겹침


두 변수의 값을 바꾸는 swap 함수를 생각해보자

template<typename T>
void my_swap(T &a, T &b)
{
	T tmp(a); // 1차 복사
	a = b; // 2차 복사
	b = tmp; // 3차 복사
}
tmp 라는 임시 객체를 생성한 뒤에, b 를 a 에 복사하고, b에 a를 복사하게 된다.
여기서 문제는 복사를 쓸데없이 3번이나 한다는 점이다.

하지만 이렇게 할 필요 없이 각 객체의 변수의 주소값을 바꿔주면 된다.

- move 함수(move semantics)

C++ 11 부터 <utility> 라이브러리에서 좌측값을 우측값으로 바꿔주는 move 함수를 제공한다.
std::move() 함수는 인자로 받은 객체를 우측값으로 변환해서 리턴해준다.
이름을 보면 무언가를 이동시킬 것 같지만, 실제로는 타입변환만 수행한다.

my_swap 함수를 이를 이용해서 변경하면

template<typename T>
void my_swap(T &a, T &b)
{
	T tmp(std::move(a));
	a = std::move(b);
	b = std::move(tmp);
}

여기서 이동 자체는 std::move 가 실행하는 것이 아니라 우측값을 받는 함수들이 오버로딩 되면서 실행되는 것이다.


- 완벽한 전달(perfect forwarding)

만약 좌측값 과 우측값을 동시에 전달할 때
매개변수가 T u 로선언되어 있으면
자동으로 모두 좌측값으로 변경되어서 u 라는 변수의 이름속에서 함수로 전달된다.
하지만 만약 매개변수가 T& u 로 선언되어 있으면
만약 우측값을 인자로 전달한 경우, 컴파일 오류가 발생한다.

이 상황을 해결하기 위해 새롭게 오버로딩 함수를 정의한다.
이 경우는 매개변수를 T& u -> const T& u 로 선언한다.
이렇게 되면 const 변수가 들어올 경우, const 로 추론하여 각각의 const  A 나 또는 이름이 없는 우측값인 A() 를 모두 받을 수 있게 된다.

그런데 만약 함수 g 가 인자를 2개 받는다고 가정하면, 이 경우 모든 조합의 템플릿 함수들을 정의해야하는 상황이 발생한다.
T& u ,T& v
const T& u, T& v
T& u, const T& v
const T& u, const T& v
만약 인자가 3개 그 이상으로 늘어나면 조합의 수가 감당할 수 없을 정도로 많아지게 된다.

일반적인 레퍼런스가 우측값을 받을 수 없으므로 이렇게 해야한다.
디폴트로 상수레퍼런스만 받게 되면, 상수가 아닌 레퍼런스도 상수 레퍼런스로 캐스팅되어서 들어간다.

- 보편적 레퍼런스(Universal reference)

만약 void wrapper(T&& u) 이면
매개변수로 T&& 로 받는다.
이렇게 템플릿 인자 T 에 대해서 우측값 레퍼런스를 받는 형태를 보편적 레퍼런스라고 한다.
이 보편적 레퍼런스는 우측값만 받는 레퍼런스와는 다르다.
우측값만 받는 레퍼런스는 5는 받을 수 있지만 만약 int a = 5; 에서 a 를 인자로 받는다면 컴파일 오류가 발생한다.

하지만 템플릿 타입의 우측값 레퍼런스(보편적 레퍼런스) 는 다르다.
우측값은 물론이고, 좌측값도 받아낼 수 있다.
만약 좌측값이 들어오면 레퍼런스 겹침 규칙(reference collapsing rule) 에 따라 T 의 타입을 추론하게 된다.

만약 const int& 를 오버로딩하는 g 를 호출하게 되면 안되므로 move 함수를 통해 u 를 다시 우측값으로 변환해야 한다.
그런데 이 경우 만약 move 함수를 계속 쓰면 만약 우측값이 아닌 좌측값이 들어온 경우, 우측값으로 변환되므로 오류가 발생한다.
따라서 move 함수를 아무때나 쓰는 것을 막기 위한 함수가 forward 함수이다.
이 함수는 u 가 우측값 레퍼런스 일때만 마지 move 를 적용한 것처럼 작동한다.