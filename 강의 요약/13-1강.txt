13-1강 객체의 유일한 소유권 - unique_ptr

- C++ 의 RAII 패턴
- unique_ptr

C++ 에서 자원을 관리하는 방법에 대해 다룬다.
컴퓨터에서 자원(resourc) 라 하면 할당한 메모리, open 한 파일 등이 존재한다.

그런데 이러한 자원은 프로그램마다 한정되어 있으므로 관리를 해주어야 한다.
즉 사용이 끝난 자원은 반드시 반환을 해서 다른 작업 때 사용할 수 있도록 해야 한다.
예를 들어 메모리를 할당만하고 해제를 하지 않는다면, 결국 메모리 부족으로 프로그램이 crash 될 수도 있다.

- 자원 관리의 중요성
C++ 이후에 나온 많은 언어들은 대부분이 가비지 컬렉터(Garbage Collector - GC) 라 불리는 자원 청소기가 내장되어 있다.
이 GC 의 역활은 프로그램 상에서 더 이상 쓰이지 않는 자원을 자동으로 해제해 주는 역활을 한다.
따라서 코드를 작성할 때, 자원을 해제하는 일에 대해 크게 신경 쓸 필요가 없다.

하지만 C++ 의 경우에는 한 번 획득한 자원은 직접 해제해 주지 않는 이상 프로그램이 종료되기 전 까지 영원히 남아있게 된다.
만약 delete 를 함수 안에서 해주지 않는다면 , 생성된 객체를 가리키던 포인터는 메모리에서 사라지게 되고, Heap 영역 어딘가에서 클래스의 객체가 남아있지만, 그 주소값을 가지고 있는 포인터는 메모리 상에서 존재하지 않게 된다.
즉 영원히 해제되지 못한 채 힙에서 자리만 차지하고 있게 된다.
예를 들어 int arr[100] 이 해제되지 못하면 100*4 = 400 바이트의 메모리 누수가 발생하게 된다.

예외는 정상적으로 처리되었을 때 메모리 해제는 되지 않는 경우가 발생할 수 있다.
즉 예외는 처리되지만 메모리 누수가 발생한 것이다.

- Resource Acquisition Is Initialization - RAII
> 자원의 획득은 초기화다
이는 자원 관리를 스택에 할당한 객체를 통해 수행한다.

예외가 발생해서 함수를 빠져나가더라도, 그 함수의 스택에 정의되어 있는 모든 객체들은 빠짐없이 소멸자가 호출된다.(이를 stack unwinding 이라 한다.)
물론 예외가 발생하지 않을 때도 함수가 종료될 때, 당연히 소멸자들이 호출된다.
만약 이 소멸자들 안에 다 사용한 자원을 해제하는 루틴을 넣는다면 좋을 것이다.

만약 포인터의 경우 객체가 아니므로 소멸자가 호출되지 않는다.
그 대신 포인터를 일반적인 포인터가 아닌, 포인터 '객체'로 만들면, 자신이 소멸될 때, 자신이 가리키고 있는 데이터도 같이 delete 하게 된다.
즉 자원 관리를 스택의 객체를 통해 수행하게 되는 것이다.

이렇게 똑똑하게 작동하는 포인터 객체를 스마트 포인터(smart pointer) 라고 부른다.
이전에는 이러한 문제를 해결하기 위해 auto_ptr 라는 것이 등장했지만 문제가 있어서 사용을 권장하지 않았다.

C++ 11 에서는 auto_ptr 를 보완한 두 가지 형태의 새로운 스마트 포인터를 제공하고 있다.
unique_ptr, shared_ptr 이다.

- 객체의 유일한 소유권 - unique_ptr
메모리를 잘못된 방식으로 관리할 경우 크게 두 가지 종류의 문제점이 발생할 수 있다.

1. 메모리를 사용한 후에 해제하지 않는 경우, 서버처럼 장시간 작동하는 프로그램의 경우 시간이 지남에 따라서 점점 사용하는 메모리의 양이 늘어나서 결과적으로 나중에 시스템 메모리가 부족해져서 서버가 죽을 수 있다.
이러한 문제는 RAII 패턴을 사용하면 해결 가능하다.
RAII 를 통해서 사용이 끝난 메모리는 항상 해제시켜 버리면 메모리 누수 문제를 사전에 막을 수 있다.

2. 이미 해제된 메모리를 다시 참조하는 경우
만약 data 와 data2 가 동시에 한 객체를 가리키고 있었는데, delete data 를 통해 그 객체를 소멸시키면 data2 가 이미 소멸된 객체를 다시 소멸시키려고 할 것이다. 보통 이럴 경우 메모리 오류가 나면서 프로그램이 죽게된다.
이렇게 이미 소멸된 객체를 다시 소멸시켜서 발생하는 버그를 double free 버그라고 한다.
위와 같은 문제가 발생한 이유는 만들어진 객체의 소유권이 명확하지 않아서이다.
만약 어떤 포인터에 객체의 유일한 소유권을 부여해서, 이 포인터 말고는 객체를 소멸시키는 것이 불가능하다 라고 정의하면 위와 같이 같은 객체를 두 번 소멸시키는 일은 없을 것이다.

따라서 data 에 new Data() 로 생성된 객체의 소유권을 보유한다면, delete data 만 가능하고, delete data2 는 불가능하게 된다.

C++ 에서는 특정 객체에 유일한 소유권을 부여하는 포인터 객체를 unique_ptr 라고 한다.

선언 방식은 다음과 같다.
std::unique_ptr<data type> 포인터이름(new data type());
이제 pa->객체멤버함수() 로 함수를 실행 가능하다.
템플릿에 인자, 포인터가 가리킬 클래스를 전달하면 된다.
std::unique_ptr<A> pa(new A());
A* pa = new A(); 
는 동일한 문장이다.
unique_ptr 는 -> 를 오버로드하여서 마치 포인터를 다루는 것 처럼 사용할 수 있게 하였다.
이 unique_ptr 덕분에 RAII 패턴을 사용할 수 있다.
pa 는 스택에 정의된 객체이므로 do_something() 함수가 종료될 때, 자동으로 소멸자가 호출된다.
그리고 이 unique_ptr 는 소멸자 안에서 자신이 가리키고 있는 자원을 해제해 주기 때문에 자원이 잘 해제될 수 있다.

만약 unique_ptr 를 복사하려 하면 컴파일 오류가 발생한다.
이때 컴파일 오류 문구로 "삭제된 함수를 사용하려 했다" 라는 문구가 나온다.

- 삭제된 함수
사용을 원치 않는 함수를 삭제시키는 방법은 C++ 11 에 추가된 기능이다.
코드에서  = delete; 라는 코드를 작성하면 프로그래머가 명시적으로 이 함수는 사용하지 말라고 표현 가능하다.
혹시 사용하면 컴파일 오류가 발생한다.
unique_ptr 도 마찬가지로 unique_ptr 의 복사 생성자가 명시적으로 삭제되었다.
그 이유는 unique_ptr 는 어떠한 객체를 유일하게 소유해야 하기 때문이다.
만일 unique_ptr 를 복사 생성할 수 있게 되면, 특정 객체를 여러개의 unique_ptr 들이 소유하게 되는 문제가 발생한다.
따라서 각각의 unique_ptr 들이 소멸될 때, 전부 객체를 delete 하려해서 앞에서 말한 double free 버그가 발생한다.

- unique_ptr 소유권 이전하기
unique_ptr 는 복사는 되지 않지만 소유권은 이전할 수 있다
즉, std::move 를 이용해서 이전 가능하다.
복사 생성자는 정의되어 있지 않지만, 이동 생성자는 가능하다. 소유권을 이동시킨다는 개념으로 생각

소유권이 이전된 unique_ptr 는 주소값을 확인해보면 nullptr(0) 이 나온다.
따라서 소유권을 이전하고 그 포인터가 가리켰던 객체의 함수를 실행하면 오류가 발생한다.
소유권이 이전된 unique_ptr 를 댕글링 포인터(dangling pointer) 라고 하고, 이를 재 참조할 시, 런타임 오류가 발생한다.
따라서 소유권 이전은 댕글링 포인터를 절대 다시 참조하지 않겠다는 확신 하에 이동해야 한다.

- unique_ptr 를 함수 인자로 전달하기
만약에 unique_ptr 를 함수 인자로 전달하고 싶다면 매개변수로 unique_ptr 의 레퍼런스를 선언하면 정상적으로 작동한다.
함수 내부로 unique_ptr 가 잘 전달되지만 이것이 문맥 상 맞는 코드인가?
unique_ptr 는 어떠한 객체의 소유권을 의미한다.
하지만 레퍼런스로 unique_ptr 를 전달하면 do_something() 함수 내부에서 ptr 는 더 이상 유일한 소유권을 의미하지 않는다.
pa 가 유일하게 소유하던 객체가 이제 함수에서 ptr 를 통해서도 소유 가능하므로 unique_ptr 는 소유권을 의미한다는 원칙에 위배되게 된다.
따라서 unique_ptr 의 레퍼런스를 사용하는 것은 unique_ptr 는 소유권이라는 중요한 존재 의미를 망각한 채 단순히 포인터의 단순한 Wrapper로 사용하는 것에 불과하다.

그렇다면 어떻게 unique_ptr 를 함수 인자로 전달해야 하는가?
> 원래의 포인터 주소값을 전달해주면 된다.
즉 pa.get() 함수로 주소값을 얻어서 인자로 전달하면 매개변수는 A* ptr 로 선언된 상태에서 주소값을 받아서 가리키게 된다.
get() : 실제 객체의 주소값을 리턴한다.
이렇게 되면 소유권이라는 의미는 버린 채, 함수 내부에서 객체에 접근할 수 있는 권한을 줄 수 있다.

*** unique_ptr 는 어떤 객체의 유일한 소유권을 나타내는 포인터이며, unique_ptr 가 소멸될 때, 가리키던 객체 역시 소멸된다.
*** 만약에 다른 함수에서 unique_ptr 가 소유한 객체에 일시적으로 접근하고 싶다면, get 를 통해 해당 객체의 포인터를 전달하면 된다.
*** 만약에 소유권을 이동하고자 한다면, unique_ptr 를 move 하면 된다.

- unique_ptr 를 쉽게 생성하기
C++ 14 부터 unique_ptr 를 간단히 만들 수 있는 std::make_unique 함수를 제공한다.

기존에는 std::unique_ptr<Foo> ptr(new Foo(3,5)); 와 같이 선언했던 것을
auto ptr =std::make_unique<Foo>(3,5); 로 선언 가능하다.

- unique_ptr 를 원소로 가지는 컨테이너
unique_ptr 는 다른 타입들과 큰 차이는 없지만, 복사 생성자가 없다는 점에서 다루기 어려운 경우가 많다.
예를 들어 unique_ptr 를 vector 에 push_back 하려 하면, push_back() 은 인자로 받은 것을 복사해서 vector 에 집어넣으므로 복사 생성자가 존재하지 않는 unique_ptr 는 오류가 발생하게 된다.

이를 방지하기 위해서 명시적으로 pa 를 vector 안으로 이동 시켜주어야 한다.
즉 push_back 의 우측값 레퍼런스를 받는 버전이 오버로딩 될 수 있도록 해야한다.
따라서 vec.push_back(std::move(pa)); 를 사용하면 된다.

하지만 이렇게 하지 않고도 vector 의 멤버 함수인 emplace_back 함수를 이용하면, vector 안에 unique_ptr 를 직접 생성하면서 집어넣기가 가능하다.
즉, 불필요한 이동 과정을 생략할 수 있다.
emplace_back 함수는 전달된 인자를 완벽한 전달(perfect forwarding) 을 통해, 직접 unique_ptr<A> 의 생성자에 전달해서 vector 맨 뒤에 unique_ptr<A> 객체를 생성해버리게 된다.
따라서 불필요한 이동 연산이 필요 없어진다.