6-1 강
string 클래스를 배운다.
-사원 관리 프로그램

1. 사원의 정보를 클래스로 만들어서 보관한다.
 이름, 나이, 직책 등등

2. 사원 데이터를 관리하는 멤버 변수를 만든다.
할당한 총 직원 수, 현재 직원 수, 직원 데이터
동적으로 데이터를 할당하는 것을 처리하기 위해서는 두 개의 변수가 필요했다.
현재 할당된 총 크기, 그 중에서 실제로 사용하고 있는 양
이렇게 해야 할당된 크기보다 더 많은 양을 실수로 사용하는 것을 막을 수 있다.

이중 포인터를 이용해서 직원의 데이터를 선언하는 이유는 우리가 Employee* 객체를 담는 배열로 사용할 것이기 때문이다.(포인터를 가리키는 포인터이므로)

-상속(Inheritance)
Manager 클래스를 추가하면서 복사 붙여넣기 를 계속하면서 어려움을 느꼈다. Manager 의 코드 자체가 Employee의 내용을 대부분 포함하고 있기 때문이다. 따라서 C++ 에서는 이러한 다른 클래스의 다른 내용을 포함하게 하는 작업을 가능하게 해준다. 이를 상속이라 한다.

상속을 통해 다른 클래스의 정보를 물려 받아서 사용할 수 있다.

멤버함수는 상속받은 클래스 안에 다시 멤버함수가 선언되지 않으면 기존의 부모 클래스의 내부에 존재하는 멤버함수가 실행된다. 
예제의 경우에 Derived에 what 함수가 정의되어 있으므로 굳이 멀리 Base까지 가지 않고 가까이 있는 Derived의 what 함수를 호출하게 된다.
>>> 이러한 것을 가리켜 오버라이딩(overriding) 이라고 한다. 즉 Derived의 what 함수가 Base의 what 함수를 오버라이딩 한 것이다.
(오버로딩 : 같은 이름의 함수를 인자를 달리 하여 정의하는 것 > 헷갈리지 말기)

만약 상속받은 자식 클래스가 부모 클래스의 private 멤버 변수에 접근하려하면 컴파일 오류가 발생한다.
사실 private 멤버 변수에는 자기 클래스 말고는 어떠한 경우에도 접근이 불가능하다.
그래서 C++ 에서는 public 과 private 의 중간 위치에 있는 접근지시자를 지원한다.
이 키워드는, 상속받는 클래스에서 접근 가능하고 그 외의 기타 정보는 접근 불가능 이다.
즉 private 는 자신만의 비밀번호, protected 는 집 현관문 비밀번호(가족들은 알음), public 는 집 주소(다른 사람도 알음)
이렇게 정리가 가능하다.

상속을 선언할 때 클래스의 이름 앞에 public, private, protected 냐에 따라서 상속 받는 클래스에서 기반 클래스의 멤버들이 실제로 어떻게 작용하는지 영향을 준다.
public 을 상속한 경우 : 기반 클래스의 접근 지시자들에 영향 없이 그대로 작동한다. 즉 파생 클래스 입장에서 상속받은 클래스의 멤버들은 public, protected, private 그대로 똑같다.
protected 을 상속한 경우 : 파생 클래스 입장에서 public 은 protected 로 바뀌고 나머지는 유지된다.
private 을 상속한 경우 : 파생 클래스 입장에서 모든 접근 지시자들이 private가 된다.

따라서 public 으로 선언된 멤버 변수는 main 함수에서도 접근이 가능하지만, 이 클래스를 private으로 상속 받은 클래스는 모든 변수와 함수를 private으로 처리되므로 접근이 불가능하다.

-사원 관리 프로그램에 적용
기본적으로 생성자는 일반 생성자, 디폴트 생성자, 복사 생성자를 선언한다.
Manager 의 calculate_pay 함수나 print_info 함수 등에서 Base 의 name, position 등을 참조하고 있기 때문에 이 멤버 변수들을 private 속성으로 놔두면 안된다. 이를 protected 로 바꿔주어야 접근이 가능하다.