13-2강 자원을 공유할 때 - shared_ptr 와 weak_ptr

- shared_ptr
- enable_shared_from_this
- weak_ptr

대부분의 경우, 하나의 자원은 한 개의 스마트 포인터에 의해 소유되는 것이 바람직하고, 나머지 접근은(소유가 아닌) 그냥 일반 포인터로 처리한다.

하지만 때에 따라서 여러 개의 스마트 포인터가 하나의 객체를 같이 소유해야 하는 경우가 발생한다.
예를 들어서 여러 객체에서 하나의 자원을 사용하고자 하면, 후에 자원을 해제하기 위해서 이 자원을 사용하는 모든 객체들이 소멸되어야 하는데, 어떤 객체가 먼저 소멸되는지 알 수 없기 때문에 이 자원 역시 어느 타이밍에 해제 시켜야 할지 알 수 없게 된다.

따라서 좀 더 스마트한 포인터가 특정 자원을 몇 개의 객체에서 가리키는지를 추적한 뒤에, 그 수가 0이 되어야 비로소 해제를 시켜주는 방식의 포인터가 필요하다.

- shared_ptr
기존에 유일하게 객체를 소유하는 unique_ptr 와는 다르게, shared_ptr 로 객체를 가리킬 경우, 다른 shared_ptr 역시 그 객체를 가리킬 수 있다.
shared_ptr 의 경우 객체를 가리키는 모든 스마트 포인터들이 소멸되어야 객체의 소멸자를 호출한다.
shared_ptr 의 참조 개수는 use_count 함수를 통해서 알 수 있다.

만약 shared_ptr 내부에 참조 개수를 저장한다면 문제가 발생한다.

따라서 처음으로 실제 객체를 가리키는 shared_ptr 가 제어 블록(contro block) 을 동적으로 할당한 후, shared_ptr 들이 이 제어 블록에 필요한 정보를 공유하는 방식으로 구현된다.

shared_ptr 는 복사 생성할 때 마다 해당 제어 블록의 위치만 공유하면 나머지 정보는 제어 블록이 제공한다.
shared_ptr 가 소멸할 때 마다 제어 블록의 참조 개수를 하나 줄이고, 생성할 때 마다 하나 늘리는 방식으로 작동한다.

- make_shared 로 생성하자
std::shared_ptr<A> p1(new A());
는 바람직한 shared_ptr 의 생성 방법이 아니다.
일단 A 를 생성하기 위해 동적 할당이 한 번 일어나고, 그 다음 shared_ptr 의 제어 블록 역시 동적으로 할당 해야하기 때문이다.
즉 두 번의 동적 할당이 발생한다.

동적 할당은 상당히 연산의 비용이 크다. 따라서 어짜피 동적 할당을 두 번 할 것을 알고 있다면, 한 번에 해버리는 것이 훨씬 빠르다.
따라서 다음과 같이 만들어 주는 것이 바람직하다.
std::shared_ptr<A> p1 = std::make_shared<A>();
make_shared 함수는 A 의 생성자들의 인자를 받아서 이를 통해 객체 A 와 shared_ptr 의 제어 블록까지 한 번에 동적 할당 한 후에 만들어진 shared_ptr 를 리턴한다.

- shared_ptr 생성 시 주의 할 점
shared_ptr 은 인자로 주소값이 전달된다면, 마치 자기가 해당 객체를 첫번째로 소유하는 shared_ptr 인 마냥 행동한다.

enable_shared_from_this 클래스에는 shared_from_this 라는 멤버 함수를 정의하고 있다.
이 함수는 이미 정의되어 있는 제어 블록을 사용해서 shared_ptr 을 생성한다.
따라서 같은 객체에 두 개의 다른 제어 블록이 생성되는 일을 막을 수 있다.

shared_from_this 가 잘 작동하기 위해서는 해당 객체의 shared_ptr 가 반드시 먼저 정의되어 있어야 한다.
즉 shared_from_this 는 있는 제어 블록을 확인만 할 뿐, 없는 제어 블록을 생성하지는 않는다.
즉 객체가 존재하지 않는 상태에서 shared_from_this 함수를 실행하면 컴파일 오류가 발생한다.

- 서로 참조하는 shared_ptr
shared_ptr 는 참조 개수가 0이 되면 가리키는 객체를 메모리에서 해제시킨다.
그런데 객체들을 더 이상 사용하지 않는데도 불구하고 참조 개수가 절대로 0이 되지 않는 상황이 존재한다.
두 개의 객체가 서로를 참조하고 있는 상황이다.
이러한 경우 순환 참조 문제가 발생한다.

- weak_ptr 
순환 참조 문제를 해결하기 위해 등장한 것이 weak_ptr 이다.

트리 구조를 지원하는 클래스를 만든다고 해보자.
트리 구조에서 한 개의 노드는 여러개의 자식 노드를 가질 수 있지만, 단 한 개의 부모 노드만을 가질 수 있다.
부모 노드들은 자식 노드들을 가리키고, 자식 노드들은 부모 노드를 가리킨다.
이러한 자료구조를 구현하려면 어떻게 해야 할까?
class Node
{
	std::vector<std::shared_ptr<Node>> children;
	type parent;

public:
	Node() {};
	void AddChild(std::shared_ptr<Node> node) { children.push_back(node); }
};

여기서 만약 parent 의 타입을 일반 포인터(Node * ) 로 하게 된다면, 메모리 해제를 까먹고 하지 않을 경우, 혹은 예외가 발생하였을 때 적절하게 자원을 해제하기 어렵다. 그리고 이미 해제된 메모리를 계속 가리키고 있을 위험도 있다.
그렇다면 만약 shared_ptr 로 하게 된다면 앞에서 다룬 순환 참조 문제가 발생하게 된다.
부모와 자식이 서로를 가리키게 되므로 참조 개수가 절대로 0이 될 수 없다. 따라서 이들 객체들은 프로그램 끝날 때 까지 절대로 소멸되지 못하고 남아있게 된다.

weak_ptr 는 일반 포인터와 shared_ptr 사이에 위치한 스마트 포인터로, 스마트 포인터 처럼 객체를 안전하게 참조할 수 있게 해주지만, shared_ptr 와는 다르게 참조 개수를 늘리지는 않는다.
따라서 만약 어떤 객체가 weak_ptr 가 가리키고 있더라도, 다른 shared_ptr 들이 가리키고 있지 않다면 이미 메모리에서 소멸되었을 것이다.
이 때문에 weak_ptr 자체로는 원래 객체를 참조할 수 없고, 반드시 shared_ptr 로 변환해서 사용해야 한다.
이 때 가리키고 있는 객체가 이미 소멸되었다면,  빈 shared_ptr 로 변환되고, 아닐 경우 해당 객체를 가리키는 shared_ptr 로 변환된다.

weak_ptr 는 생성자로 shared_ptr 이나 다른 weak_ptr 를 받는다.
또한 shared_ptr 과는 다르게, 이미 제어 블록이 만들어진 객체만이 의미를 가지므로 평범한 포인터 주소값으로 weak_ptr 를 생성할 수는 없다.
weak_ptr 그 자체로는 원소를 참조할 수 없고, shared_ptr 로 변환해야 한다.
이 작업은 lock 함수를 통해 수행 가능하다.
weak_ptr 에 정의된 lock 함수는 만일 weak_ptr 가 가리키는 객체가 아직 메모리에서 살아있다면(참조 개수가 0이 아니라면) 해당 객체를 가리키는 shared_ptr 를 반환하고, 이미 해제가 되었다면 아무 것도 가리키지 않는 shared_ptr 를 반환한다.
아무것도 가리키지 않는 shared_ptr 는 false 로 형변환 되므로 위와 같이 if 문으로 간단히 확인 가능하다.