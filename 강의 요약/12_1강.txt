12-1강 우측값 레퍼런스와 이동 생성자

- 복사 생략(Copy elision)
- 우측값 레퍼런스(rvalue referen ce)
- 이동 생성자(move constructor)


- 복사 생략

임시 객체를 한 번 만들고 이를 복사 생성할 필요가 없다.
임시 객체를 바로 만들어진 객체로 해버리면 되기 때문이다.

따라서 컴파일러가 복사 생성을 굳이 수행하지 않고, 임시로 만들어진 객체를 사용한다.
이렇게 컴파일러 자체에서 복사를 생략해 버리는 작업을 복사 생략(copy elision) 이라고 한다.

이렇게 복사 생략을 하는 경우는 '함수의 인자가 아닌' 함수 내부에서 생성된 객체를 그래도 리턴할 경우,
수행할 수 있다. C++ 17 부터는 반드시 복사 생략을 하도록 바뀌었다.


nullptr 는 C++ 11 에 새로 추가된 키워드이다. 
이는 기존의 NULL 을 대체한다.
C 언어에서의 NULL 은 #define 으로 정의되어 있는 상수값 0인데, 이 때문에 NULL 값이 0을 의미하는 것인지 아니면 포인터 주소값 0을 의미하는 것인지 구분할 수 가 없었다.

하지만 nullptr 는 포인터 주소값 0 을 정확히 의미하게 되므로 실수를 줄일 수 있다.

str3 = str1 + str2 연산을 하는 경우를 생각해보자

이 경우 operator+ 연산자 오버로딩에서 내부에서 str 을 생성한 후, 그리고 메모리를 할당하고, 문자열의 길이를 새롭게 정의하고, 문자열을 복사한 뒤 return str; 을 통해서 str3 의 복사생성자를 호출하는 과정을 거치게 된다.
하지만 굳이 str3 의 복사 생성자를 호출할 필요가 없다.
이미 리턴한 객체를 str3 치고 사용하면 된다.
만약 str1 과 str2 의 크기가 엄청나게 컸다면?
쓸데 없는 복사를 두 번 하는데 상당한 자원이 사용되었을 것이다.

- 좌측값(lvalue) 와 우측값(rvalue)
모든 C++ 표현식의 경우, 두 가지 카테고리로 구분 가능하다.
1. 이 구문이 어떤 타입을 가지냐
2. 어떠한 종류의 값을 가지냐

int a = 3; 
이라는 식을 보면 여기서 a 는 메모리 상에서 존재하는 변수이다.
즉 a 의 주소값을 & 연산자를 통해 알아낼 수 있다.
보통 이렇게 주소값을 취할 수 있는 값을 좌측값(lvalue) 라고 부른다.
그리고 좌측값은 어떠한 표현식의 왼쪽 오른쪽 모두에 올 수 있다.
> 무조건 왼쪽에 오는 것은 아니다!

위 식의 오른쪽에 있는 3을 보면, 이 3은 주소값을 취할 수 없다.
3은 왼쪽의 'a' 와 다르게 , 위 표현식을 연산할 때만, 사용되고 사라지는 값이다.
즉 3은 실체가 없는 값이다.

이렇게 주소값을 취할 수 없는 값을 우측값(rvalue) 라고 부른다.
이름에서도 알 수 있듯이, 우측값은 식의 오른쪽에만 항상 올 수 있다.
좌측값은 식의 왼쪽 오른쪽 모두 올 수 있지만, 우측값은 식의 오른쪽에만 존재한다.

& 하나를 이용해서 정의하는 레퍼런스를 좌측값 레퍼런스(lvalue reference)라고 부른다.
그리고 좌측값 레퍼런스 자체도 좌측값이 된다.

앞서 살펴본 문자열 클래스는 보면
MyString str3 = str1 + str2; 의 코드는
MyString str3(str1.operator+(str2));
와 동일하다.
MyString MyString::operator+(const MyString &s)
로 우측값을 리턴하고 있다.
이 경우 우측값을 리턴하지만 생성자를 호출할 수 있는 이유는
&가 좌측값 레퍼런스를 의미하지만, 예외적으로 const T& 타입에 한해서, 우측값도 레퍼런스로 받을 수 있다.
그 이유는 const 레퍼런스 이기 때문이다. 임시로 존재하는 객체의 값을 참조만 할 뿐, 이를 변경할 수 없다.

그렇다면 위의 operator+ 는 어떻게 작동할까?
str1 + str2 가 리턴한 임시 생성 객체에서 string_length 와 memory_capacity 는 값을 그냥 복사하면 되고
string_content 는 기존에 임시 객체가 가리키고 있던 문자열을 연결을 끊고, 문자열 전체를 복사하여 이동할 필요 없이 임시 객체가 가리키던 객체를 가리키게 바꿔주면 된다.
그리고 임시 객체의 문자열이 가리키던 것은 소멸자 호출을 하지 않게 그냥 연결만 끊어준다.
즉 임시 생성된 객체의 string_content 를 nullptr 로 바꿔주면 소멸자가 호출되지 않고 소멸되지 않는다.
하지만 이 방법은 기존의 복사 생성자에서는 사용할 수 없었다.
인자를 const MyString& 으로 받으므로, 인자의 값을 변경할 수 없다.
즉 임시 객체의 string_content 값을 수정할 수 없기에 문제가 발생한다.
> const MyString& 이 좌측값과 우측값 모두를 받을 수 있다는 점에서 문제가 발생하는 것이다.
그렇다면 const 를 사용하지 않고, 좌측값만 기본으로 받으면서 우측값만 특이적으로 받을 수 있는 방법을 사용하면 되지 않을까?
C++ 11 부터는 우측값 레퍼런스를 제공한다.

우측값 레퍼런스는 && 두 개를 사용하여 정의한다.
이동 생성자의 정의를 살펴보면
MyString::MyString(MyString&& str)
{
	std::cout << "이동 생성자 호출!" << std::endl;
	string_length = str.string_length;
	string_content = str.string_content;
	memory_capacity = str.memory_capacity;

	str.string_content = nullptr;
}
이렇게 하면 임시 객체의 string_content 가 가리키는 메모리를 새로 생성되는 객체의 메모리로 옮겨주면 된다.
그리고 기존의 메모리는 str.string_content = nullptr; 를 통해서 연결을 끊어준다.
기존의 복사 생성자는 문자열 전체를 새로 복사해야 했지만, 이동 생성자의 경우, 단순히 주소값 하나만 복사해주면 되므로 매우 간단하게 복사를 할 수 있다.

여기서 중요한 부분은, 임시 객체가 소멸되면서 자신이 가리키던 문자열을 delete 해버리면 안된다는 점이다. 만약 문자열을 delete 하면서 소멸하게 된다면, 새롭게 생성된 문자열 str3 도 같은 메모리를 가리키고 있으므로 같이 소멸되게 된다.
따라서 절대로 그냥 delete 하면 안되고 str 의 string_content 를 nullptr 로 바꿔준다.

string_content 가 nullptr 가 아닐 때만 delete 를 하도록 소멸자도 같이 바꿔줘야 한다.
즉
MyString::~MyString()
{
	if(string_content) delete[] string_content;
}
이렇게 해주면 만약 string_content = nullptr 라면 실행되지 않는다.

우측값 레퍼런스의 특징 중 하나는 레퍼런스 하는 임시 객체가 소멸되지 않도록 붙들고 있는다는 점이다.
MyString&& str3 = str1 + str2;
str3.println();
이라는 함수를 실행하면 str3 이 str1 + str2 에서 리턴되는 임시 객체의 레퍼런스가 되면서 그 임시 객체가 소멸되지 않도록 한다.

- noexcept 키워드 : 일종의 예외 사양이다. 함수는 예외를 throw 하지 않으며 예외가 해당 범위 외부로 전파되는 것을 허용하지 않는다.
연산자(operator) 와 한정자(specifier) 의 형태로 제공된다.
즉 함수 선언 시 그 함수가 예외를 방출하지 않을 것임을 명시할 때는 noexcept 라는 키워드를 사용한다.
함수의 예외 방출 행동은 클라이언트에게 아주 중요한 사항이다. 함수의 호출자는 함수의 noexcept 여부를 조회하며, 이는 호출 코드의 예외 안정성이나 효율성에 영향을 미친다.
즉, 함수의 noexcept 여부는 멤버함수의 const 여부만큼 중요한 정보이다.
이 키워드는 이동연산과 swap, 메모리 해제 함수, 그리고 소멸자에 특히 유용하다.

- 이동 생성자 작성 시 주의할 점
vector 를 예로 생각해보자.
새로운 원소를 추가할 때, 할당해놓은 메모리가 부족하다면, 새로운 메모리를 할당하고 기존의 원소들을 새로운 메모리로 옮기게 된다.
복사 생성자를 사용할 경우, 원소가 하나하나 복사되게 된다.
그런데 이 복사 과정에서 예외가 발생한 경우, 새로 할당한 메모리를 소멸시킨 후, 사용자에게 예외를 전달하면 된다.
그런데 이동 생성자를 사용한 이동 생성과정에서 예외가 발생한 경우, 기존의 메모리에 원소들이 모두 이동되어서 사라져버렸기 때문에 문제가 발생한다.
즉 새로 할당한 메모리를 섯불리 해제 불가능하다.
따라서 vector 의 경우, 이동생성자에서 예외가 발생하였을 때 이를 제대로 처리할 수 없다.
이는 C++ 다른 컨테이너들도 동일하다.
따라서 vector 는 이동 생성자가 noexcept , 즉 예외를 절대로 발생시키지 않는다는 보장이 없으면 이동생성자를 사용하지 않는다.
만약 이동생성자와 복사생성자가 둘 다 존재할 때, noexcept 키워드가 이동생성자에 붙지 않았다면, 컴파일러는 복사생성자를 사용하게 된다.
하지만 MyString::MyString(MyString && str) noexcept 를 적으면
컴파일러가 제대로 이동 생성자를 호출하는 것을 알 수 있다.

식별성을 가진다면 glvalue, 다른 메모리로 이동 가능하면 rvalue, 그리고 식별성을 가짐과 동시에 다른 메모리로 이동가능하면 xvalue, 다른메모리로 이동가능하지만 식별 불가능하면 prvalue 이다.