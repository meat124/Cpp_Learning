10-2강 C++ STL - set, map, unordered_set, unordered_map


시퀀스 컨테이너(vector, list, deque)는 말 그대로 '원소' 자체를 보관하는 컨테이너이다.

다른 종류의 컨테이너인 연관 컨테이너(assocative container) 에 대해서 알아본다.
연관 컨테이너는 시퀀스 컨테이너 와 다르게 키(key) - 값(value) 구조를 가진다.
즉 특정한 키를 넣으면 이에 대응하는 값을 돌려준다.
물론 템플릿 라이브러리 이므로 키 와 값 모두 임의의 타입의 객체가 될 수 있다.

1. 특정 키가 연관 컨테이너에 존재하는지 유무
2. 만약 존재한다면 이에 대응되는 값이 무엇인지
C++ 에서는 위의 두 가지 작업을 처리할 수 있는 연관 컨테이너를 제공한다.
전자의 경우 set과 multiset 이고, 후자의 경우 map 과 multimap 이다.
물론 맵과 멀티맵을 셋 처럼 사용할 수 있다. 왜냐하면 해당하는 키가 맵에 존재하지 않으면 당연히 대응되는 값을 가져올 수 없기 때문이다. 하지만 맵의 경우 셋보다 사용하는 메모리가 크기 때문에, 키의 존재유무만 궁금하다면 셋을 사용하는 것이 좋다.

- 셋(set)
셋에 원소를 추가하려면 insert 함수를 사용한다. 시퀀스 컨테이너 처럼 어디에 추가할지에 대한 정보가없다. 즉 시퀀스 컨테이너가 상자 하나에 원소를 한 개 씩 담고, 각 상자에 번호를 매긴 것 이라면, 셋은 그냥 큰 상자안에 모든 원소들을 쑤셔 넣은 것과 같다. 원소가 어디에 있는지는 중요한 것이 아니다.
그 상자 안에 원소가 있냐/없냐 만이 중요한 정보이다.

셋에 원소를 추가하거나 지우는 작업은 O(log n) 으로 처리된다. 시퀀스 컨테이너의 경우, 임의의 원소를 지우는 작업이 O(n) 으로 수행되었다는 점을 생각하면 훨씬 빠르다.

셋 역시 셋에 저장되어 있는 원소들에 접근하기 위해서 반복자를 제공한다.
반복자는 BidirectionalIterator 이다. 즉 시퀀스 컨테이너의 리스트처럼 임의의 위치에 있는 원소에 접근하는 것은 불가능하고 순차적으로 하나씩 접근하는 것 밖에 불가능하다.

이때 중요한 점은 셋은 내부에 원소를 추가할 때 정렬된 상태를 유지하면서 추가한다.
셋을 큰 상자라 생각했는데, 상자에 순서를 지키면서 쑤셔 넣는다고 보면 된다.
이 때문에 시퀀스 컨테이너와는 다르게 원소를 추가하는 작업이 O(log n)으로 진행된다.
또한 셋은 원소가 있냐/없냐 를 판단할 때 매우 중요하다.

셋에는 find 함수가 제공되며, 만약 해당하는 원소가 존재하면 이를 가리키는 반복자를 리턴하고, 만약 존재하지 않는다면 s.end() 를 리턴하게 된다.
만약 벡터였다면 원소가 존재하는지 아닌지 확인하기 위해서 처음부터 끝까지 하나씩 비교해가면서 찾아야 했다.만약 원소가 없었더라면 벡터의 모든 원소를 확인했을 것이다. 즉 벡터에서는 find 함수는 시간복잡도가 O(n) 이었다.
하지만 셋의 경우는 find 함수를 시간 복잡도 O(log n) 으로 확인할 수 있다. 이는 셋이 내부적으로 원소들이 정렬된 상태를 유지하기 때문에 비교적 빠르게 원소의 존재 유무를 확인할 수 있다.
셋은 내부적으로 트리 구조로 구성되어 있다.
즉 각각의 원소들은 트리의 각 노드들에 저장되어 있고 다음의 규칙을 가진다.
1. 왼쪽에 오는 모든 노드들은 자신보다 작다.
2. 오른쪽에 오는 모든 노드들은 자신보다 크다.

> 원소를 검색하는데 필요한 횟수는 트리의 높이와 정확히 일치한다.
트리의 경우, 최대한 모든 노드들을 꽉 채우는 것이 중요하다. 즉 균형잡힌 트리를 만들어야 의미있는 트리를 만들 수 있다.
연관 컨테이너는 항상 트리를 균형잡히게 유지하고 있으며 따라서 셋의 구현 상 O(log n) 으로 원소를 검색할 수 있다는 것이 보장된다.
셋의 중요한 또 다른 특징은 셋 안에는 중복된 원소들이 없다는 점이 있다.
셋 자체적으로 이미 같은 원소가 있다면 insert 하지 않는다.
시퀀스 컨테이너와 마찬가지로 set 역시 범위 기반 for 문을 지원한다.
원소들의 접근 순서는 반복자를 이용해서 접근할 때와 동일하다.
만약 중복된 원소를 허락하고 싶다면 멀티셋을 사용하면 된다.

클래스의 객체를 셋의 원소로 사용할 때 주의해야 할 점이 있다.
만약 우리가 직접 만든 객체를 셋의 원소로 사용하면 셋은 기본적으로 원소가 들어갈 때 정렬해서 들어가는데 직접 정의한 객체는  <, > 연산자가 정의되어 있지 않아서 비교가 수행되지 못한다. 따라서 컴파일러가 오류를 내는 것이다.
따라서 클래스에 직접 operator< 를 만들어 주어야 한다.
이때 연산자를 구현할 때 함수를 반드시 상수함수에 상수 매개변수로 선언해야 한다.
그 이유는 set 내부적으로 정렬 시에 상수 iterator 를 사용하기 때문이다. 따라서 상수 iterator 는 상수 함수만을 호출 가능하므로 무조건 상수로 선언해야 한다.
셋은 중복원소를 허용하지 않으므로 만약 같은 경우를 if 문으로 구현하지 않으면 원소가 추가되지 않는다.

- 맵(map)
셋의 경우 key만 보관했지만, 맵의 경우 key 에 대응되는 value 까지도 같이 보관하게 된다.
템플릿 인자로 2개를 가지는데 첫 번째는 키의 타입이고 두 번째는 값의 타입이다.
맵에 원소를 넣기 위해서는 반드시 std::pair 객체를 전달해야 한다.
template<class T1, class T2>
struct std::pair{
	T1 first;
	T2 second;
};
이다.
그런데 객체를 사용할 때 마다 템플릿 인자를 초기화 하는 것은 귀찮으므로 STL 에서는 std::make_pair 함수를 지원한다.
이 함수는 인자로 들어오는 객체를 보고 타입을 알아서 추측해서 알아서 std::pair 객체를 만들어서 리턴해준다. 따라서 굳이 귀찮게 프로그래머가 인자의 타입을 보고 적어줄 필요가 없다.
>> pitcher_list.insert(std::make_pair("박현진", 3.04));
"박현진" 은 string, 3.04 는 double 로 자동으로 인식해서 객체 리턴해줌
그리고 맵의 경우, operator[] 를 이용해서 새로운 원소를 추가할 수도 있다.
> 만약 해당하는 키가 이미 존재한다면 그에 대응하는 value 가 대체될 것이다.

맵의 경우도 셋과 마찬가지로 반복자를 이용해서 순차적으로 맵에 저장되어 있는 원소들을 탐색할 수 있다.
참고로 셋의 경우 *itr 가 저장된 원소를 바로 가리켰는데, 맵의 경우 반복자가 맵에 저장되어 있는 std::pair 객체를 가리키게 된다.
따라서 itr->first 를 하면 해당 원소의 key, itr->second 를 하면 해당 원소의 value 를 알 수 있다.
[] 연산자를 이용해서 값을 참조하는 경우, 존재하지 않는 키 임에도 불구하고, 0이라는 값이 리턴되는 것을 확인할 수 있다.
이는 디폴트 연산자로 값이 초기화되기 때문이다. 따라서 먼저 find 함수로 원소가 키가 존재하는지 확인 한 뒤, 값을 참조하는 것이 좋다. 즉 먼저 if 문의 조건에 find != end() 를 이용해서 확인한 뒤 값을 참조하는 편이 에러를 줄일 수 있다.

맵 역시 셋처럼 중복 원소를 허락하지 않는다.
따라서 같은 키가 원소로 들어온다면 insert 는 무시된다.
따라서 만약 원소에 대응되는 값을 바꾸고 싶다면 insert 함수가 아닌, [] 연산자로 대응되는 값을 바꾸어 주면 된다.

- 멀티셋과 멀티맵(multiset, multimap)

멀티셋과 멀티맵은 중복된 원소를 허락한다.
멀티셋에 insert 를 이용해서 중복된 원소를 삽입하면 정렬되어서 같은 원소가 두 개 이상 존재하는 것을 확인할 수 있다.
멀티맵의 경우, 한 개의 키에 여러개의 값이 대응될 수 있다. 
이때 멀티맵에서는 [] 연산자의 사용이 불가하다.
그 이유는 당연하게도 어떠한 키 값에 여러개의 값이 존재하면 어떤 것을 리턴해야 할지 컴파일러가 알 수 없기 때문이다.
find 함수는 해당하는 키가 없으면 m.end() iterator 를 리턴한다.
만약 키 값이 같은 것들을 find 함수로 찾으면 어떤 값을 리턴할지는 C++ 표준에도 정해있지 않다. 즉 아무거나 리턴해도 상관이 없다는의미이다. 

- unordered_set, unordered_map 
비교적 최근에 나온 컨테이너 이다.
원소들이 정렬되어 있지 않다.
셋이나 맵의 경우, 원소들이 정렬되어서 들어가지만 ,원소들이 순서대로 정렬돼서 들어가지 않는다는 의미이다.
따라서 반복자로 원소들을 하나씩 출력해보면 거의 랜덤한 순서로 나오는 것을 볼 수 있다.

string문자열 순서도 아니고 완전 랜덤한 순서로 나온다.
그런데 이 컨테이너의 경우, insert, erase, find 함수가 모두 시간복잡도 O(1) 로 실행된다는 아주 큰 장점이 존재한다.
기존에 셋이나 맵의 경우, O(log n) 이었지만, 
이 경우는 상수시간에 원소를 삽입하고 검색이 가능하다.

- 해시함수(Hash Function)
해시함수란 임의의 크기의 데이터를 고정된 크기의 데이터로 대응시켜주는 함수이다.
이때 보통 고정된 크기의 데이터라고 하면 일정 범위의 정수값을 의미한다.

unordered_set 과 unordered_map 의 경우, 해시함수는 1부터 D 까지 (상자의 수)
해시함수의 가장 중요한 성질 : 같은 원소를 해시함수에 전달한다면 같은 해시값을 리턴한다.

파란공을 해시 함수에 대입하면 1을리턴한다. 그러면 1번 상자를 살펴보면 이미 파란공이 있는 것을 알 수 있다. 따라서 파란공이 셋에 존재하는 것을 확인 가능하다.
만약 빨간색 공과 보라색 공처럼 다른 원소임에도 같은 해시값을 갖는 경우가 생길 수 있다. 이 경우를 해시 충돌(Hash Collision)이라고 하며, 이 경우 같은 상자에 다른 원소들이 있게 된다.
따라서 보라색 공이 이 셋에 포함되어 있는지 확인하고 싶다면, 보라색 공의 해시값을 찾은 뒤, 긜고 해당하는 상자에 모든 원소를 탐색하면 된다. 이 경우 원소는 그렇게 크기가 많지 않기 때문에 금방 탐색이 가능하다.

해시함수의 설계는 보통 1~N 까지의 고른 값을 반환하도록 설계된다.
그리고 상자의 수도 충분히 많아야 상수 시간 탐색을 보장할 수 있다.
하지만 운이 매우 나쁘다면 다른 색들의 공이 모두 1번 상자에 들어갈 수 도 있다. 이 경우 탐색은 O(1) 이 아니라 O(n) 이 될 것이다.

따라서 평균적으로 O(1) 의 시간으로 원소의 삽입/탐색을 수행할 수도 있지만 최악의 경우는 O(n) 으로 실행될 수도 있다.
즉 보통의 경우는 안전하게 맵이나 셋을 사용하고, 만약 최적화가 매우 필요한 작업이라면 해시함수를 잘 설계해서 고르게 값을 반환하게 설계하고 unordered set/map 을 사용하는 것이 바람직하다.

또한 처음부터 많은 개수의 상자를 사용하기 어려우므로, 상자의 개수는 삽입되는 원소의 개수가 많아짐에 따라 점진적으로 늘어난다.
상자의 개수가 늘어나면 해시함수를 바꿔야 하므로(더 많은 값들을 해시값으로 바꿔야 하므로) 모든 원소들을 처음부터 끝까지 다시 rehash 라고 해야 한다. 이는 O(n) 만큼의 시간 복잡도를 가진다.
사용법은 기존의 set, map 과 동일하다.
만약 내가 만든 클래스를 unordered set/map 에 넣고싶다면 직접 해시함수를 만들어주어야 한다.
그래도 기본적인 타입들은 C++ STL에서 해시함수를 제공하므로 우리는 이 함수들을 잘 섞어서 만들어주면 된다.
따라서 직접 해시함수를 만드는 작업은 권장하지 않는다.

데이터의 존재 유무 만 궁금할 경우 → set

중복 데이터를 허락할 경우 → multiset (insert, erase, find 모두 O(\log N)O(logN). 최악의 경우에도 O(\log N)O(logN))

데이터에 대응되는 데이터를 저장하고 싶은 경우 → map

중복 키를 허락할 경우 → multimap (insert, erase, find 모두 O(\log N)O(logN). 최악의 경우에도 O(\log N)O(logN))

속도가 매우매우 중요해서 최적화를 해야하는 경우 → unordered_set, unordered_map

(insert, erase, find 모두 O(1)O(1). 최악의 경우엔 O(N)O(N) 그러므로 해시함수와 상자 개수를 잘 설정해야 한다!)