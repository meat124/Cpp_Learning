5-2강

이번 강좌에서는
1. 멤버 함수가 아닌 연산자 함수 오버로딩
2. 입출력 연산자 오버로딩(<<, >> 연산자)
3. 첨자 연산자 [] 오버로딩
4. 타입 변환 연산자 오버로딩
5. 증감 연산자 ++, -- 오버로딩
에 대해 다룬다.

-friend 키워드
friend 키워드는 클래스 내부에서 다른 클래스나 함수들을 friend로 정의할 수 있다. 이때 이 키워드로 정의된 클래스나 함수들은 원래 클래스의 private 으로 정의된 변수나 함수에 접근할 수 있다.

A 클래스 내부에 클래스 B와 void func 를 friend 키워드를 붙여서 선언하고 있다. 이는 친구라고 선언하는 것이다. 이러한 선언을 통해 클래스 B와 void func는 A클래스에 접근권한을 얻게된다.
하지만 A 클래스는 반대로 B 클래스에 접근이 불가능하다.

std::ostream& operator<<(std::ostream& os, const Complex& c)
위의 코드에서 인자로 받는 std::ostream& os 는 
이항 연산자에서 cout << c;
라는 코드에서 연산자인 << 양쪽에 존재하는 cout 가 std::ostream& os 로 들어가고 c 가 const Complex& c로 들어가는 것이다.

-이항 연산자
저번 강좌에서 다음과 같은 문제점이 있었다.
a = a + "-1.1 + i3.923";
는 잘 컴파일 되지만
a = "-1.1 + i3.923";
은 컴파일 되지 않았다.
왜냐하면 위는 a.operator+("i3.923"); 으로 변환되지만 아래는 그렇지 못하기 때문이다.
하지만 아래가 컴파일 되지 않는다면 연산자 오버로딩을 할 이유가 없다.
어떤 임의의 연산자 @ 가 존재한다면
*a.operator@(b);
*operator@(a,b); 
중 컴파일러가 가능한 것을 골라서 처리한다. 따라서 위의 코드는 a 클래스의 멤버 함수로 사용되고, operator@(a,b)는 클래스 외부에 정의되어 있는 일반적인 함수를 의미한다. 따라서 이를 처리하기 위한 새로운 함수를 정의해야 한다.
여기서 인자를 Complex& a 라는 인자로 받는다.
그런데 우리는 문자열에 써있는 복소수를 변수로 변환시켜서 계산하기를 원한다.
따라서 이 문자열을 Complex 클래스의 변수로 변환시키는 생성자가 존재하기 때문에 연산이 가능해진다. 즉 const char* str을 인자로 받는 생성자가 사용된다.
따라서 오버로딩이 되면서 인자가 변환된다.
즉 const Complex& a 라는 인자에 문자열 "-1.1 + i3.923" 이라는 인자가 전달되면 이는 
Complex("-1.1 + i3.923") 이라는 생성자로 변환되어 변수에 저장된다.
>> 오버로딩 적용
그런데 Complex operator+ 함수가 제대로 작동하려면 이 함수가 Complex 클래스의 private 변수인 a,b의 real, img 변수에 접근이 가능해야한다. 따라서 이 함수를 Complex 클래스에 friend 키워드를 이용해서 선언하면 된다.

자기 자신을 리턴하지 않는 이항연산자는 +,-,*,/  전부 외부 함수로 선언하는 것이 원칙이다. 반대로 자기 자신을 리턴하는 이항연산자(+=, -= 등) 은 멤버 함수로 선언하는 것이 원칙이다.

iostream 헤더파일을 보면 그 안에 istream, ostream 이 include 되어있다.
여기서 엄청난 수의 operator<< 연산이 정의되어 있는 것을 알 수 있다. 즉 오버로딩이 되고 있는 것이다. 따라서 우리가 이를 통해서 편하게 인자의 타입과 상관없이 bool, short, int, double 등등.. 많은 것을을 출력할 수 있게 되는 것이다.
그렇다면 우리가 이를 이용해서 
Complex c;
std::cout << c; 
를 출력으로 나타내고싶으면 어떻게 해야할까.
우리가 표준헤더파일을 수정할 수는 없으므로 우리가 직접 만들어본 클래스에 연산자 함수를 추가하면 된다. 
여기서 리턴 타입이 ostream& 가 되는 이유는 
std::cout << "a 의 값은 : " << a << " 이다. " << std::endl;
이라는 문장을 처리할 수 있게 하기 위해서이다.

무분별한 friend 키워드 남발은 권장되지 않는다.
"구현 디테일은 최대한 숨겨라" 라는 원칙을 지키기가 힘들어지기 때문이다.
따라서 상황을 보면서 friend 가 꼭 필요한 상황에만 사용하는 것이 바람직하다.

-첨자 연산자([])

배열에서 원소를 지정할 때 사용되는 첨자 연산자 [] 를 오버로딩 해본다.
[] 안에 들어가는 수를 첨자(subscript)라고 부른다.
예를 들어 str[10] 이라는 코드는 str 배열의 10번째 인덱스의 값에 접근하게 해준다.
코드는 다음과 같다
char& operator[](const int index) { return string_content[index]; }

-int Wrapper 클래스(타입 변환 연산자)
무언가를 포장하는 클래스 라는 의미를 가지며
C++ 에서 기본 자료형들을 객체로써 다루어야 할 때가 있다.
int, float와 같은 기본 자료형들을 클래스로 포장해서 다룰 때 필요한 것이 Wrapper 클래스이다.
int 자료형을 감싸는 int Wrapper 클래스 Int 는 다음과 같다.

class Int
{
   int data;

 public:
   Int(int data) : data(data) {}
   Int(const Int& i) : data(i.data) {}
}


-전위/후위 증감 연산자
전위 연산자는
operator++();
operator--(); 이라는 방식으로 오버로딩을 진행한다.
후위 연산자는
operator++(int x);
operator--(int x);
여기서 인자 x는 아무런 의미가 없다. 
다만 컴파일러가 전위/후위를 구별하기 위해 인자를 넣어주는 것이다.
따라서 다음과 같이 선언해도 차이는 없다
operator++(int)
operator--(int)

전위 증감 연산의 경우 값이 바뀐 자기 자신을 리턴하고, 후위 증감의 경우 값이 바뀌기 이전의 객체를 리턴한다.
int x = 1;
func(++x); 
라는 코드는 전위 증감 연산이므로 func에 2를 인자로 전달하지만
int x = 1;
func(x++);
라는 코드는 후위 증감 연산이므로 func에 1을 인자로 전달하고 증감을 해서 x = 2가 된다.
따라서 이는 다음과 같은 형태가 된다.
A& operator++()
{
   return *this
} // 전위연산

A& operator++(int)
{
   A temp(A);
   // A++ 을 수행한다.
   return temp;
} // 후위 연산

++을 하기 전에 객체를 반환해야 하므로 temp 객체를 임시로 만들어서 이전의 상태를 기록하고 ++을 수행한 뒤 temp 객체를 반환하게 된다. 따라서 후위 증감 연산은 전위 증감 연산에 비해 추가적으로 복사 생성자를 호출하기 때문에 전위 증감 연산보다 속도가 조금 느리게 된다.

-연산자 오버로딩 정리
1. 두 개의 동등한 객체 사이에서의 이항 연산자는 멤버 함수가 아닌 외부 함수로 오버로딩 하는 것이 좋다.( 예를 들어 Complex 의 operator+(const Complex&, const Complex&) 와 같은 함수)
2. 두 개의 객체 사이의 이항 연산자 이지만 한 객체만 값이 바뀐다든지 하는 등의 동등하지 않은 이항 연산자는 멤버 함수로 오버로딩 하는 것이 좋다. 
예를 들어 operator+= 는 이항 연산자 이지만 실제로는 한쪽으로만 값이 변경되므로 
operator+=(const Complex&) 가 더 나은 경우에 해당된다.
3. 단항 연산자는 멤버 함수로 오버로딩하는 것이 좋다.
예를 들어 operator++ 의 경우 멤버 함수로 오버로딩한다.
4. 일부 연산자들은 반드시 멤버 함수로만 오버로딩 해야 한다.