14강 함수를 객체로

- Callable 의 정의
- std::function
- std::mem_fn
- std::bind


- Callable
호출 할 수 있는 모든 것을 나타낸다.
C++ 에서는 ()를 붙여서 호출할 수 있는 모든 것을 Callable 이라고 정의한다.

- std::function
이러한 Callable 들을 객체의 형태로 보관할 수 있는 std::function 이라는 클래스를 제공한다.
C 에서 함수 포인터는 진짜 함수들만 보관할 수 있는 객체라고 볼 수 있다면, std::function 의 경우, 함수 뿐 만이 아니라 모든 Callable 들을 보관할 수 있는 객체이다.

function 객체는 템플릿 인자로 전달 받을 함수의 타입을 갖게 된다.
함수의 타입은 리턴값과, 함수의 인자들을 의미한다.

따라서 리턴 타입이 int 이고, 인자로 const string& 을 받으면 std::function<int(const string&)> 의 형태로 정의된다.

Functor 클래스인 S 의 객체의 경우 단순히 S 의 객체를 전달해도 이를 함수처럼 받게 된다.
S 의 경우 operator() 가 인자로 char 를 받고, 리턴 타입이 void 이므로 std::function<void(char)> 로 정의된다.

마지막으로 람다 함수의 경우, 리턴값이 없고 인자를 받지 않으므로 std::function<void()>로 정의된다.

만약 함수 포인터로 이러한 것들을 구현하려 했다면 Functor 와 같은 경우를 성공적으로 구현할 수 없을 것이다.
하지만 std::function 을 사용하여 이러한 것들이 구현 가능하다.

- 멤버 함수를 가지는 std::function
멤버 함수 내에서 this 의 경우, 자신을 호출한 객체가 무엇인지 알 수 없는 경우가 발생한다.
사실 멤버 함수들은 구현 상, 자신을 호출한 객체를 인자로 암묵적으로 받고있다.

따라서 객체 정보를 전달하기 위해서, 원래 인자에 객체를 받는 인자를 전해주면 된다.
이때 상수 함수의 경우 상수 형태로 인자를 받아야 하고(const), 반면에 상수 함수가 아닌 경우 단순히 객체의레퍼런스를 받으면 된다.

그런데 이전의 함수들과는 다르게 &A::some_func 와 같이 함수의 이름 만으로는 그 주소값을 전달할 수 없다.
멤버 함수가 아닌 모든 함수들의 경우, 함수의 이름이 함수의 주소값으로 암시적 변환이 일어나지만, 멤버 함수들의 경우, 암시적 변환이 발생하지 않으므로 & 연산자를 통해 명시적으로 주소값을 전달해줘야 한다.
>> 멤버 함수를 function 으로 저장 시에 & 를 붙이는 것을 확인하라 !

- 멤버 함수들을 함수 객체로 - mem_fn

transform 함수는 <algorithm> 라이브러리에 있는 함수로, 각 원소들에 대해 , 인자로 전달된 함수를 실행한 다음, 그 결과를 전달된 컨테이너에 넣어준다.
그런데 4번째 원소에 멤버함수를 전달하면 컴파일 오류가 발생한다.
이때 이 멤버 함수를 function 객체를 만들어서 전달하면 된다.

하지만 매번 function 객체를 따로 만들어서 전달하는 것은 귀찮다.
따라서 c++ 개발자들은 라이브러리에 function 객체를 리턴해버리는 함수를 추가했다.
그것이 바로 mem_fn 함수이다.
mem_fn 함수는 이름 그대로, 전달된 멤버 함수를 function 객체로 만들어서 리턴해준다.

- std::bind
함수 객체 생성 시에 인자를 특정한 것으로 지정할 수도 있다.
bind 함수는 원래 함수에 특정 인자를 붙여준다.
이때 bind 함수에 인자로 전달되는 std::placeholder::_n 은 n 번째 인자를 받는다는 의미이다.
n 은 1~29 까지 정의되어 있다.

만약 bind 함수에서 레퍼런스를 전달해야 한다면, std::ref 함수를 사용하면 된다.
ref 함수는 전달받은 인자를 복사 가능한 레퍼런스로 변환해준다.
따라서 bind 함수 안으로 s1 의 레퍼런스가 잘 전달될 수 있다.
만약 const 레퍼런스라면 cref 함수를 호출하면 된다.

