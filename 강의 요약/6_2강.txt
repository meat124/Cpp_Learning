6-2 강

-is '-a' 와 'has -a'

상속(inheritance)은 단순히 코드를 또 쓰는 것을 막기 위해 도입한 것이 아니다.
상속을 통해서 객체지향 프로그래밍에서 추구하는 실제 객체의 추상화를 좀 더 효과적으로 할 수 있다.

C언어에서는 어떠한 구조체 사이의 관계를 표현할 수 있는 방법이 없었다. 하지만 C++에서는 상속을 통해서 클래스 사이의 관계를 표현할 수 있게 되었다.
class Manager : public Employee
라는 코드의 의미는
-Manager 클래스는 Employee 의 모든 기능을 포함한다.
-Manager 클래스는 Employee 의 기능을 모두 수행할 수 있기 때문에 Manager를 Employee 라고 칭해도 무방하다.
-즉 모든 Manager는 Employee 이다.
-> Manager is a Employee
따라서 모든 상속 관계는 is a 관계라고 볼 수 있다. 여기서 이를 뒤바꾸면 성립되지 않는다. 즉 Manager 는 Employee 이지만 Employee 는 Manager 가 아니다.
is a 관계로 이뤄진 것은 수없이 많다. 사람이라는 클래스가 있다면 프로그래머 라는 클래스는 사람 클래스를 상속 받을 수 있도록 구성할 수 있다.
또한 은행 계좌 라는 클래스가 있고 자유롭게 입출금이 가능한 계좌지만 이자가 없다. 라는 클래스와 비교적 자유롭게 입출금이 불가능하지만, 매 달 이자가 붙음. 이라는 클래스는 같은 계좌지만 기능이 약간씩 다르다. 즉 은행계좌라는 일반적인 클래스를 상속받은 것이다.
즉 클래스가 파생되면 파생될 수록 좀 더 특수화(구체화;specialize) 된다는 의미이다. 즉 Employee 클래스가 일반적인 사원을 위한 클래스 였다면, Manager 클래스들은 그 일반적인 사원들 중에서도 좀 더 특수한(근속연수가 오래된) 부류의 사원들을 의미하게 된다.
반대로 기반 클래스로 올라가면 올라갈 수록 좀 더 일반화(generalize)된다고 말한다.
즉 
기반 클래스 -> 파생 클래스 : 특수화, 구체화(specialize)
파생 클래스 -> 기반 클래스 : 일반화(generalize)
라고 정리할 수 있다.
하지만 모든 클래스들을 is a 관계로 정리할 수는 없다.
어떤 클래스들은 has a 관계가 성립하기도 한다.
예를 들어 자동차 클래스를 생각해 보면 자동차 클래스를 구성하기 위해서는 엔진, 브레이크, 오디오 클래스 등등 여러가지 수 많은 클래스가 필요하다. 그렇다고 여기에 is a 관계를 도입할 수는 없다. 
즉 자동차는 엔진을 가진다. (car has a engine) , 자동차는 브레이크를 가진다.(car has a brake) 등등 has a 관계로 쉽게 표현이 가능하다.
이러한 관계에서는 클래스에서 private 멤버 변수로 부품을 선언하면 된다.

-오버라이딩
앞의 강좌에서 다뤘듯이, 기반 클래스에서 함수를 호출하면 그대로 실행되고 기반 클래스를 상속받은 파생 클래스에서 같은 이름의 함수를 재 정의 해서 호출하면 기반 클래스의 함수를 오버라이드해서 파생 클래스의 함수가 호출된다.
Base* p_c = &c;
라는 코드에서 이러한 대입이 가능한 이유는 Derived is a Base 이기 때문에 Base* 형태여도 Derived 레퍼런스가 대입이 가능하다. 즉 Derived 가 Base를 상속받고 있으므로 가능하다.
Derived 객체 c도 Base 객체이기 때문에 Base 객체를 가리키는 포인터가 c를 가리켜도 무방하다는 것이다.
포인터의 자료형이 Base 이므로 함수를 실행한다면 포인터는 자신의 자료형인 Base 클래스에 존재하는 what 함수로 실행하게 된다. 이러한 형태의 캐스팅을 업 캐스팅이라고 한다.( 파생 클래스에서 기반 클래스로 캐스팅 하는 것) 즉 Base 의 클래스의 포인터이면 초기화 값으로 Derived 레퍼런스가 들어와도 함수는 Base 의 함수로 실행

반면 Derived 포인터가 Base 객체의 레퍼런스를 받아서 가리킨다고 생각해보자. 이 경우에 what 함수를 호출하면 이는 불가능하다. 그 이유는 포인터는 Base 객체를 가리키는데 Derived 에 대한 정보가 없기 때문이다. 즉 Base 는 Base 의 정보만 알지만, Derived 는 Base 와 Derived 모두 알기 때문에 업캐스팅이 된다.
하지만 그 반대인 다운캐스팅은 컴파일러에가 금지하고 있다.
물론 이중 포인터 연결 구조에서 가리키는 변수의 클래스가 동일하다면 다운 캐스팅을 통해서 실행이 가능하지만, 이러한 작동이 보장되지 않는다면 다운캐스팅은 권장하지 않는다.

-dynamic_cast

이러한 캐스팅에 따른 오류를 미연에 방지하기 위해서 C++ 에서는 상속관계에 있는 두 포인터들 간에 캐스팅을 해주는 dynamic_cast 라는 것을 지원한다. 이는 static_cast 와 사용이 거의 동일하다.


-virtual 키워드
이 키워드는 다음과 같은 역활을 한다.
컴파일 시에 어떤 함수가 실행될 지 정해지지 않고, 런타임 시에 정해지는 일을 가리켜서 동적 바인딩(dynamic binding) 이라고 부른다.
따라서 Derived 의 what 을 실행할지, Base 의 what 을 실행할지 결정은 런타임에 이루어지게 된다.
반대로 우리가 지금까지 해오던 컴파일 타임에 어떤 함수가 실행될지 정해지는 것을 정적 바인딩(static binding) 이라고 한다. 
이러한 virtual 키워드가 붙은 함수를 가상 함수(virtual function)이라고 한다. 이렇게 파생 클래스의 함수가 기반 클래스의 함수를 오버라이드 하기 위해서는 두 함수의 꼴이 정확히 같아야 한다.

오버라이딩 : 부모 클래스와 자식 클래스 사이에서만 성립된다. static 메소드는 클래스에 속하는 메소드이기 때문에 상속되지 않고 오버라이드 되지도 않는다. private 의 접근 지시자를 가진 메소드는 상속이 되지 않아 오버라이드도 성립되지 않는다. 오버로드와 달리 리턴 타입, 메소드 명, 매개변수 패턴이 모두 같아야 한다. 부모 클래스의 메소드의 접근 지시자 범위보다 작아질 수 없고 확장은 가능하다. 
> 오버라이드는 메소드 하나로 여러 객체를 다루고 객체마다 다른 기능을 사용할 수 있다는 장점이 있다.
다형성 : 하나의 클래스나 함수가 다양한 방식으로 동작하는 것을 의미한다. 오버로딩에서는 하나의 메소드로 여러 동작을 할 수 있고, 오버라이드에서는 여러 클래스의 다른 기능을 하나의 메소드로 제어할 수 있다.
따라서 프로그래밍에서 효율성을 아주 크게 높여줄 수 있는 객체지향 프로그래밍(OOP)의 중요한 특징 중 하나이다.

-override 키워드
파생 클래스에서 기반 클래스의 가상 함수를 오버라이드 하는 경우, override 키워드를 통해서 명시적으로 나타낼 수 있다.

만약 함수의 이름은 같은데 하나는 const 선언을 통해 상수함수이고 하나는 그냥 일반 함수이면 오버라이드가 제대로 진행되지 않는다. 컴파일러의 입장에서는 두 함수는 서로 다른 함수로 간주된다.

이제 Employee 프로그램의 문제를 해결할 수 있다.
Employee 의 함수들 앞에 virtual 키워드를 붙여서 선언하고
Manager 클래스의 함수들에 override 키워드를 추가해주면 이제 자동으로 오버라이딩이 되어서 실행된다.
다형성(polymorphism)