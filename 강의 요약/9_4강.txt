9-4 강 템플릿 메타 프로그래밍 2


- 의존 타입
- Unit 라이브러리 만들기
- auto 키워드
에 대해 알아본다.

클래스에 템플릿 인자를 전달할 때, 템플릿 특수화 상황에서 만약 값인지 타입인지 명확하게 정의되지 않으면 컴파일러 오류가 발생할 수 있다.
따라서 이러한 상황을 막기 위해 템플릿 인자에 따라서 어떠한 타입이 달라질 수 있는 것을 의존 타입이라 하고 이 경우 앞에 typename 을 적어주어서 해결한다.
이렇게 하면 컴파일러에게 이 변수는 타입이라고 알려주는 것이 된다.

만약 의존 '값'이라면 typename 을 붙이지 않아도 된다.
컴파일러는 기본적으로 어떤 식별자를 보았을 때 '값'이라고 생각한다.

컴파일러에 따라서 재귀적으로 몇 번까지 사용 가능한지 깊이가 정해져 있다.
따라서 큰 수를 넣는다면 재귀적으로 반복이 너무 많이 진행되어서 컴파일 오류가 발생할 수 있다.

일반적인 클래스가 아니라 TMP 로 만든 이유가 무엇일까

- 단위(Unit) 라이브러리

수치 계산을 하는데 C++ 을 사용한다.
이때 꼭 필요한 것이 바로 단위이다.

만약 가속도이면 m/s^2 으로 데이터를 받고, 시계는 s 단위로 데이터를 받을 것이다.

그런데 만약 속도를 더할 때 , 실수로 속도와 가속도를 더하는 연산을 해버렸다면 만약 속도와 가속도가 자료형이 float 이라면
> 오류가 발생하고 심지어 그 오류가 어디서 발생했는지 확인하기는 더 어렵다.
만약 단위 데이터를 클래스를 만들어서 클래스 객체에서 보관하기로 해보자
그렇다면 연산자들을 오버로딩 한 뒤에,  연산 시에 객체끼리 단위를 체크해서 단위가 맞지 않으면 처리하면 된다.

하지만 위의 방법은 문제가 존재한다. 만약 틀린 단위를 연산하는 코드가 매우 드물게 일어난다면 > 런타임에서 그 문제를 확인하지 못하고 넘어갈 수도 있다.
따라서 가장 이상적인 상황은 단위가 맞지 않는 연산을 수행할 때, 컴파일 시에 오류를 발생시키는 것이다.
즉 이 경우 틀린 단위를 연산하는 일을 아예 막을 수 있고 프로그램을 실행하면서 런타임을 기다리는 수고를 덜 수 있다.

+ 와 - 연산의 경우 피 연산자의 단위가 일치해야 연산이 진행되지만, * 와 / 연산의 경우 피 연산자의 단위가 일치하지 않아도 된다. 단위가 다르면 새로운 단위가 탄생하는 것이기 때문이다.
예를 들어 가속도는 meter / (second * second) 로 표현된다.
>> 새로운 차원의 데이터 Dim<zero, one, minus_two> 로 표현됨

즉 우리가 만약 Force 를 나타내고 싶다면 정의를 다음과 같이 하면 된다.
quantity<double, Dim<one, one, Ratio<-2, 1>>> F = kg * meter / (second * second);
자료형은 double 이고 질량 차원은 1, 길이 차원은 1, 시간 차원은 -2 인 단위가 kg*m/s^2 인 Force 의 단위가 탄생한다.

- 타입을 알아서 추측하는 -auto 키워드
만약 (??) kg(1); 이라는 코드라면 컴파일러 입장에서는 이것이 차원을 의미하는 것인지 아니면 그냥 int 타입을 의미하는 것인지 알 수 가 없다. 
하지만 (??) F = kg * meter / (second * second); 이라는 코드는 컴파일러가 오른쪽의 연산을 통해서 F 의 타입을 정확하게 알아낼 수 있다.
이렇게 컴파일러가 정확하게 타입을 알아낼 수 있는 경우, 굳이 프로그래머가 긴 타입을 적는 대신에 간단히 auto 키워드로 표현할 수 있다.
즉 위에서 만들어본 F 의 타입을 그냥 다음과 같이 간단하게 정의 가능하다
auto F = kg * meter / (second * second);

따라서 복잡한 타입 이름의 경우, 그 타입을 쉽게 추측할 수 있다면 auto 키워드를 활용하는 것도 좋다.
TMP 는 특성상 복잡하고, 버그가 발생하였을 때 찾는 것이 매우 어렵다.
하지만 Unit 클래스처럼 TMP 를 적절하게 활용하면 런타임에서 찾아야 하는 오류들을 컴파일 타임에서 다 잡을 수도 있고, 런타임 시에 수행해야 하는 연산들도 일부 컴파일 타임으로 옮길 수 있다.
TMP 를 편하게 작성하기 위한 라이브러리인 boost::MPL 이 있다.