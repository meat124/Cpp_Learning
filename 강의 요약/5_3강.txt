5-3강

-C++스타일의 캐스팅
C언어에서는 컴파일러에서 알아서 캐스팅하는 암시적 캐스팅과, 우리가 직접 캐스팅하라고 지정하는 명시적 캐스팅이 존재했다.
암시적 캐스팅의 경우 int 와 double 변수와의 덧셈을 수행할 때, int 형 변수가 자동으로 double 변수로 캐스팅 되는 것을 말했다. 그리고 명시적 캐스팅의 경우 void* 타입의 주소를 특정 구조체 포인터 타입의 주소로 바꾸는 등의 캐스팅이 존재했다.

이때 명시적 캐스팅은 앞에 () 를 붙이고 형을 명시하는 식으로 진행되었다.
하지만 이러한 캐스팅 방법은 다음과 같은 상황에서 문제가 발생한다.
1. 말도 안되는 캐스팅에 대해 컴파일러가 오류를 발생시키지 않는다. 즉 프로그래머의 실수에 취약하다.
2. 코드의 가독성이 떨어진다. 괄호안에 타입을 넣으므로
괄호가 많아지면 가독성이 떨어지게 된다.

따라서 C++ 에서는 총 4가지의 캐스팅을 지원한다.
1. static_cast : 우리가 흔히 생각하는, 언어적 차원에서 지원하는 일반적인 타입 변환
2. const_cast : 객체의 상수성(const)를 없애는 타입 변환, 쉽게 말해 const int 가 int 로 바뀐다.
3. dynamic_cast : 파생 클래스 사이에서의 다운 캐스팅
4. reinterpret_cast : 위험을 감수하고 하는 캐스팅(서로 관련이 없는 포인터들 사이의 캐스팅)

예를 들어서 static_cast 로 float 타입의 float_variable 이라는 변수를 int 타입의 변수로 변환하기 위해서는
static_cast<int>(float_variable);
이렇게 코드를 작성하면 된다.
이는 (int)(float_variable); 이라는 코드와 동일한 문장이다.
대부분의 캐스팅은 보통 static_cast로 진행이 된다.

-N 차원 배열 만들기
사용자가 원하는 배열의 차원이 존재한다면
그 배열을 일차원으로 구현한 뒤에 접근할 경우 그 정확한 위치를 찾아주는 방식으로 N차원 배열의 생성이 가능하다.
동적으로 2차원 배열을 구현할 때 다음과 같은 코드를 통해 구현하였다.
int** arr; // 이중포인터 선언
arr = new int*[x1]; // 먼저 포인터로 1차 동적할당
for(int i=0;i<x1;i++)
   arr[i] = new int[x2];

이러면 아래로 가지를 뻗는 듯한 모습으로 배열의 할당이 가능해진다.
3차원 배열은 삼중포인터를 사용해서 선언하면 된다.
즉 문어발 형식으로 배열을 구현하는 것이다.
처음에는 x1개의 int* 배열을 생성한 뒤, 각각의 int*에 대해서 x2개의 int 배열을 만드는 것이다.
이러하면 int arr[x1][x2] 를 한 것과 정확히 동일한 효과를 낸다.
하지만 이러한 방식은 메모리를 추가적으로 더 잡아먹는다.
int arr[x1][x2]는 메모리를 x1*x2 만큼 잡아먹지만
위에서 다룬 방식은 메모리를 x1*x2 + x1 + 1만큼 잡아먹는다는 단점이 존재한다.

하지만 장점도 존재한다.
이러한 방식은 메모리가 허용하는 한, 크기가 매우매우 큰 배열도 생성할 수 있다는 점이다.

구조체를 통해서 다음과 같이 선언을 한다.
struct Address
{
   int level;
   void* next;
}
이렇게 하면 처음에 top이라는 Address 객체를 도입이 되고 거기에 level = 0; 이 저장된다. 그리고 top의 next에는 레벨 1인 Address 배열의 시작 주소가 들어간다. 그렇게 되면 top이 가리키고 있는 Address 배열의 각각 원소들의 level은 1이 되고, 이들의 next 에는 이번에는 Address 배열이 아닌, int 배열의 시작주소가 들어가게 된다.(왜냐하면 2차원 배열이므로 이제 마지막이기 때문, 실질적으로 데이터는 이 곳에 보관이 된다.)
이때 포인터는 타입에 상관없이 값을 보관해야 하므로 void* 포인터로 선언하며 이는 필요할 때 적당한 포인터 타입으로 변환하면 된다.
즉, 최종적으로 N 차원 배열은 Address 에서 0레벨부터 N - 1 레벨까지 생성되며, N-1 레벨의 경우 next 에 실제로 보관할 데이터에 해당하는 배열(int) 의 시작 주소값이 들어가게 되며, 나머지 0~N-2레벨까지는 그 다음 레벨의 Address 배열의 시작 주소값이 들어가게 된다.
즉 3차원 배열의 경우
(3-1) 레벨의 Address 들의 next가 int 배열의 시작주소값을 가리키게 된다.

이러한 방식을 도입하는 이유는 각 레벨에서의 배열 크기가 모두 다를 수 있기 때문이다.
예를 들어서 arr[3][2][1] 을 했을 경우, 1 레벨의 배열 크기가 3이고 2레벨의 배열 크기가 2리고 마지막 int 배열의 크기가 1이 된다.