11-1강 C++ 에서의 예외 처리

목차
- C++ 에서의 예외 처리
- throw, try, catch

만약 크기가 3인 vector 를 만들었는데 4번째 원소를 요청하고 있다면?
문법상 아무 문제가 없는 코드이지만, 막상 실행하면 오류가 발생하게 된다.

만약 큰 메모리를 할당하는 경우라면?
문법 상 틀린것이 없는 코드이지만 오류가 발생하게 된다.

이렇게 정상적인 상황에서 벗어난 모든 예외적인 상황들을 예외(exception) 이라고 부른다.

- 기존의 예외 처리 방식
C 언어에서는 언어 차원에서 제공하는 예외 처리 방식이라는 것이 딱히 따로 존재하지 않았다.

따라서 아래와 같이, 어떤 작업을 실행한 뒤에 그 결과값을 확인하는 방식으로 처리하였다.

예를 들어서 malloc 으로 메모리를 동적할당하는 상황을 보자.

메모리 할당 실패시에 NULL 을 리턴하므로 예외적인 상황을 처리할 수 있었다.

하지만 이러한 방식으로 예외를 처리하게 된다면, 함수가 깊어지면 깊어질 수록 꽤나 귀찮아진다.

- 예외 발생시키기 - throw
만들어진 vector 의 요청한 위치에 있는 원소를 리턴하는 함수를 생각해보자

이 at 함수는 인자로 전달된 index가 범위 이내라면, 간단하게 data[index] 를 리턴하면 되지만, 범위밖이라면?
> 기존에 문제는 at 함수가 const T& 를 리턴하므로, 따로 오류메시지를 리턴하기 어려웠다.
하지만 C++ 에서는 다음과 같이 예외가 발생하였음을 명시적으로 알릴 수 있다.
if(index >= size)
	throw std::out_of_range("vector 의 index 가 범위를 초과하였습니다.");

C++ 에서는 예외를 던지고 싶다면, throw 로 예외를 전달하고 싶은 객체를 써주면 된다.
아무 객체나 던져도 상관이 없지만, C++ 표준 라이브러리에는 이미 여러가지 종류의 예외들이 정의되어 있으므로 이를 활용하는 것이 좋다.
위의 경우는 out_of_range 를 throw 하고, 그 외에 overflow_error, length_error, runtime_error 등등 여러가지가 정의되어 있고, 표준 라이브러리에서 활용되고 있다.

이렇게 예외를 throw 하게 되면, throw 한 위치에서 즉시 함수가 종료되고, 예외 처리하는 부분까지 점프하게 된다.
따라서 throw 밑에 있는 모든 문장은 실행되지 않는다.
한 가지 중요한 점은 이렇게 함수에서 예외 처리하는 부분까지 도달하기 까지 함수를 빠져나가면서 stack 에 생성되었던 객체들을 빠짐없이 소멸시켜 준다는 점이다. 따라서 예외가 발생하여도 사용하고 있는 자원들을 제대로 소멸시킬 수 있다.
(소멸자만 제대로 작성하였다면)

- 예외 처리 하기 - try 와 catch

try 안에서 무언가 예외가 발생할 만한 코드가 먼저 실행된다.
만약 예외가 발생하지 않았다면 마치 try - catch 부분이 없는 것처럼 동일하게 실행된다.
data 에는 vec 의 index 번째 값이 들어가고, 밑에 있는 catch 문은 무시된다.

반면 예외가 발생할 경우 이야기가 달라진다.
예외가 발생하게 되면, 그 즉시 stack 에 생성된 모든 객체들의 소멸자들이 호출되고, 가장 가까운 catch 문으로 점프한다.
out_of_range 클래스에서 what() 함수로 문자열 값을 들여다 볼 수 있다.

- 스택 풀기(stack unwinding)
앞서 throw 를 하게 된다면, 가장 가까운 catch로 점프한다고 하였다.
즉 다른 함수에서 catch 가 없다면 main 함수의 catch 로 돌아가게 된다.
이와 같이 catch 로 점프하면서 스택 상에서 정의된 객체들을 소멸시키는 과정을 스택 풀기(stack unwinding) 이라고 한다.

** 예외를 생성자에서 던질 때 주의해야 할 점 : 생성자에서 예외가 발생 시에 소멸자가 호출되지 않는다는 점.
따라서 예외를 던지기 이전에 획득한 자원이 있다면 catch 에서 잘 해제해줘야 한다.

- 여러 종류의 예외 받기
어러 종류의 예외를 받으려면 한 개의 try 안에 받고자 하는 모든 종류의 예외를 catch 문으로 달면 된다.
마치 switch 문 처럼 catch 를 사용할 수 있다.

일반적으로 예외 객체는 std::exception 을 상속받는 것이 좋다.
STL 의 유용한 함수들 사용가능

- 모든 예외 받기

만약 어떤 예외를 throw 하였는데 이를 받는 catch 가 없다면?
runtime_error 예외를 발생시키며 프로그램이 비정상 종료가 된다.
때로는 예외 객체 하나하나 처리할 필요 없이 그냥 나머지 전부 다를 원할 때
마치 else 같은 구문이 필요하다.

try ... catch 문에서 이를 지원한다.

템플릿으로 정의되는 클래스의 경우, 어떠한 방식으로 템플릿이 인스턴스화 되냐에 따라서 던지는 예외의 종류가 달라질 수 있다.
이 때문에 해당 객체의 catch 에서는 모든 예외 객체를 고려해야 한다.

- 예외를 발생시키지 않는 함수 noexcept

만약 어떤 함수가 예외를 발생시키지 않는다면 noexcept 를 통해 명시할 수 있다.
int foo() noexcept {} 
이렇게 예외를 발생시키지 않는 함수는 함수 정의 옆에 noexcept 를 넣음으로써 나타낼 수 있다.

이러한 키워드를 넣어도 예외를 절대로 발생시키지 않는 것은 아니다.
이 키워드가 붙은 함수는 컴파일러가 그대로 컴파일 하게 된다.
경고는 발생한다.